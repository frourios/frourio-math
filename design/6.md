# フルーリオ代数学 LEAN4実装 第6フェーズ設計書（P3 詳細）

バージョン: 1.0
対象期間: Phase P3（Ore 交換式 / 非可換側の下地）
担当: 開発/形式化チーム

## 0. 目的とスコープ

- 目的: Ore 系 `Δ a - σ(a) Δ = δ(a)` の具体例を少なくとも1つ「非自明な Δ」で構成し、σ-導分の API を整備。将来の skew 多項式環 `A⟨Δ;σ,δ⟩` と PBW 的正規形（normal ordering）に向けた骨組みを提供する。
- スコープ: `Frourio/Algebra/CrossedProduct.lean` 内の Ore 節を中心に強化。行列表現による退化でない例（`Δ ≠ 1, Δ ≠ 0`）を構成。Skew 多項式の完全構成は対象外、ただし正規形に関する書換え補題の雛形は含める。

## 1. 現状とギャップ

- 既存
  - `IsSigmaDerivation`（σ-導分）と `OreSystem` の抽象定義、トリビアル例 `toTrivialOreSystem`（`E=A, Δ=1, σ=id, δ=0`）。
  - 交叉積や PBWModule の基盤（P0）がほぼ整備済み。
- ギャップ
  - `Δ` が実質単位元の退化例のみ。`Δ` が非自明で、`σ` 非自明でも Ore 交換が成立する具体モデルが未実装。
  - Skew 多項式環 `A⟨Δ;σ,δ⟩` に対応する正規形（左から右への押し出し）に関する補題群が未整備。

## 2. 成果物（Deliverables）

- D1: 非自明な Ore 系の具体例（行列表現）
  - `A : Type*` を可換環（`[CommRing A]`）とし、`E := Matrix (Fin 2) (Fin 2) A` を選ぶ。
  - 埋め込み `algebraMap : A → E` は対角埋め込み `a ↦ diag(a, σ a)`（σ は任意の `A →+* A`）。
  - `Δ := J := \begin{pmatrix}0 & 1\\ 0 & 0\end{pmatrix}`（Jordan ブロック）。
  - `δ := 0`（零導分）、`σ` は任意（少なくとも環自己準同型）。
  - 検証: `J * diag(a,σ a) - diag(σ a, σ(σ a)) * J = 0 = algebraMap (δ a)`。
  - 従って `OreSystem A` の具体インスタンスを提供（`Δ` 非自明）。

- D2: σ-導分の基本コンストラクタ
  - `isSigmaDerivation_zero (σ) : IsSigmaDerivation σ (fun _ => 0)`
  - 記号・API 整備: 以後 `δ=0` の場合に流用。

- D3: 正規形（normal ordering）の書換え補題（雛形）
  - 書換え則の型: `Δ ⋅ a = (σ a) ⋅ Δ + δ a`。
  - 単一ステップの正規化補題（`Δ a` を右側へ押し出す）。
  - `δ=0` 版では `Δ a = (σ a) Δ` のみ。
  - PBWModule（`m=1`）と連携した「単項式レベル」の移項補題の雛形を提示（証明は将来拡張）。

- D4: CrossedProduct との橋渡し（設計）
  - `m=1` の Z 作用 `σ` を与えたとき、`A⟨Δ;σ,0⟩` の単項式集合が `CrossedProduct A 1` の単項式と対応する設計メモ。
  - 実装は段階的（証明は P0 の PBW 補題再利用）。

- D5: 文書化
  - Ore 系の目的・使用場所、`δ=0` でも `Δ` 非自明であることの意義を説明。
  - 将来の `δ ≠ 0` 例（微分や差分）への拡張余地を記述。

## 3. 仕様（API と補題の型）

- D1: 行列 Ore 系（非自明 Δ）
  - `noncomputable def OreSystem.matrixJordan (A : Type*) [CommRing A]
      (σ : A →+* A) : OreSystem A :=
      { E := Matrix (Fin 2) (Fin 2) A,
        algebraAE := by infer_instance,
        ringE := by infer_instance,
        Δ := ![![0, 1], ![0, 0]],
        σ := σ,
        δ := fun _ => 0,
        isSigmaDerivation := isSigmaDerivation_zero σ,
        ore_rel := by -- 1 行計算: J diag(a,σ a) - diag(σ a, σ(σ a)) J = 0
          intro a; -- `simp` で対角と Jordan の積を展開して 0 を示す
          sorry }`
  - 備考: `diag(a,σ a)` は `Matrix.diagonal ![a, σ a]` として実装予定。`simp` 補題を整備。

- D2: σ-導分
  - `lemma isSigmaDerivation_zero (σ : A →+* A) : IsSigmaDerivation σ (fun _ : A => 0)`

- D3: 正規形の書換え補題（雛形）
  - `lemma ore_rewrite_one (sys : OreSystem A) (a : A) :
      sys.Δ * algebraMap A sys.E a
        = algebraMap A sys.E (sys.σ a) * sys.Δ + algebraMap A sys.E (sys.δ a)`
  - `δ=0` 版（即時 corollary）
  - 反復形（`Δ^n a` の正規化）ステートメントのみ（証明は将来）

- D4: CrossedProduct 設計メモ
  - `m=1` の場合、`CrossedProduct A 1` の単項式 `{ base := a, scales := fun _ => n }` は `A⟨Δ;σ,0⟩` の `a ⋅ Δ^n` に対応する。
  - `PBWModule.mul` のねじれ係数が `σ` の作用と一致することを再確認（既存補題 `pbw_mul_single_single` を参照）。

## 4. 実装手順（Tasks）

1) σ-導分ゼロ補題（D2）
- `isSigmaDerivation_zero` を追加。

2) 行列表現の Ore 系（D1）
- `OreSystem.matrixJordan` を追加。`ore_rel` は 2×2 行列の成分計算で 0 を示す。
- `simp` セット: Jordan と対角の行列積を簡約する補助補題をローカルに作成（過度な一般化は避ける）。

3) 正規形の書換え（D3）
- `ore_rewrite_one` を `ore_rel` の両辺移項として提供。
- 反復版は Statement のみ（`TODO`）で、今フェーズの受入基準外。

4) 文書整備と注釈（D5）
- ファイルセクションに目的・今後の拡張（`δ ≠ 0` の例）を記述。

## 5. 依存関係と影響範囲

- 依存: `Matrix`（`Mathlib/Data/Matrix`）、`Algebra` 基本。
- 影響: 新規定義と補題追加のみ。既存 API を壊さない。

## 6. 受入基準（Acceptance Criteria）

- AC1: `isSigmaDerivation_zero` が利用可能。
- AC2: `OreSystem.matrixJordan` が型付けされ、`ore_rel` の証明が実装済み（`δ=0`）。
- AC3: `ore_rewrite_one`（単一ステップ正規化）の補題が提供される。
- AC4: CI を通過し、既存ファイルに影響を与えない。

## 7. リスクと緩和

- R1: 行列計算で `simp` が過剰展開して遅くなる
  - 緩和: ローカルタクティクスと最小限の `simp` セットを使用、`by decide`/`fin_cases` で添字有限集合を処理。
- R2: `algebraMap` の対角実装で型が煩雑
  - 緩和: 明示的に `Matrix.diagonal` と `Pi` 型の coercion を `simp` ライブラリで調整。
- R3: 非自明 δ の例が未提供
  - 緩和: 本フェーズでは `δ=0` に留め、将来 `A = R[X]`, `δ = d/dX` へ拡張予定と明記。

## 8. 命名規約とスタイル

- 命名: `OreSystem.matrixJordan`, `isSigmaDerivation_zero`, `ore_rewrite_one`。
- コメント: 「目的」「使用」「将来拡張」の 3 点を各ブロックに明記。

## 9. マイルストーン

- M1: D2（σ-導分ゼロ）完了
- M2: D1（行列 Ore 系）完了
- M3: D3（正規形 1 ステップ）完了
- M4: 文書整備（D5）完了

## 10. 実装メモ

- 2×2 Jordan と対角の計算
  ```lean
  -- J = ![![0,1],[0,0]], D(a) = diagonal ![a, σ a]
  -- J * D(a) = ![![0, σ a],[0,0]],
  -- D(σ a) * J = ![![0, σ a],[0,0]]
  -- 差は 0
  ```
- `ore_rewrite_one`
  ```lean
  -- sys.ore_rel a : Δ a - σ(a) Δ = δ(a)
  -- → Δ a = σ(a) Δ + δ(a)
  ```
