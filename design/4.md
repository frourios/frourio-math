# フルーリオ代数学 LEAN4実装 第4フェーズ設計書（P1 詳細）

バージョン: 1.0
対象期間: Phase P1（構造列 S_n と Φ差分の拡充 / 解析ブリッジ直前）
担当: 開発/形式化チーム

## 0. 目的とスコープ

- 目的: 構造列 S と Φ差分の基礎を拡充し、Mellin 側の解析（P2）へスムーズに接続できる形へ整える。
- スコープ: `Frourio/Algebra/StructureSequence.lean` の補題整備、`S` と `phiDiff`/`phiDiffIter` の API 拡充、`phiFactorial`/`phiBinom` の有用補題追加。Mellin 変換やノルム評価自体は対象外。

## 1. 現状とギャップ

- 既存（概略）
  - `S Λ n = Λ^n - Λ^{-n}`、基本性質（奇関数、S_0、S_1、加法公式）あり。
  - `phiDiff`、一次 Leibniz（積）公式、`phiDiffIter` 再帰定義。
  - `phiFactorial`、`phiBinom` の定義、対称性および基本漸化（階乗の succ）。
- ギャップ
  - `S` の hyperbolic 形（`2*sinh(n*log Λ)`）と単調性・符号に関する系が未整備。
  - `phiBinom` の端点・Pascal 型再帰・非零仮定の扱い（仮定付き）補題が不足。
  - 高階 Leibniz（一般 n）のステートメントと前提条件（分母非零、評価点の整形）を設計化する必要。

## 2. 成果物（Deliverables）

- D1: 構造列 S の解析的同値と性質
  - `S_as_sinh`: `Λ > 0 → S Λ (n:ℤ) = 2 * Real.sinh ((n:ℝ) * Real.log Λ)`（整数 n 用）
  - 符号/単調性: `Λ > 1 → 0 ≤ n → 0 ≤ S Λ n` 等、必要最小限の不等式補題セット
  - 自明点: `S 1 n = 0` は既存、`S Λ 0 = 0` 等の `@[simp]` 整備
- D2: Φ-数と Φ-二項の拡張
  - `[n]_Φ`: `phiNum Λ n := S Λ (n : ℤ) / S Λ 1`（定義または略称補題）
  - 端点（仮定付き）: `S Λ 1 ≠ 0 → phiBinom Λ n 0 = 1`, `phiBinom Λ n n = 1`
  - Pascal 型再帰（仮定付き）: `phiBinom Λ (n+1) k = phiBinom Λ n k + c * phiBinom Λ n (k-1)`（適切な係数 c; 設計で型と仮定を明示）
- D3: 高階 Leibniz のステートメント（設計）
  - `higher_leibniz`: `phiDiffIter Λ n (f*g) = ∑_{k=0}^n (phiBinom Λ n k) • (shifted f,g の組み合わせ)`
  - ここで「shifted」は `f (Λ^k * x)` と `g (x / Λ^{n-k})` 型の評価を想定。分母の正規化は `phiDiff` の定義に従い、整合を確保。
  - 本フェーズでは完全証明を狙わず、帰納の骨格と必要補題（分配/置換/指数法則）を固める。

## 3. 仕様（API と補題の型：案）

以下、`Λ : ℝ`, `n k : ℕ`, `m : ℤ`、必要に応じて `hΛpos : 0 < Λ`、`hΛne1 : Λ ≠ 1` を仮定。

- D1: 構造列 S（hyperbolic 形）
  - `lemma S_as_sinh (hΛpos : 0 < Λ) (m : ℤ) :
      S Λ m = 2 * Real.sinh ((m : ℝ) * Real.log Λ)`
    - 技術: `zpow`→`Real.exp` と `sinh` 定義（`(exp a - exp (-a))/2`）の比較。
  - 単調性/符号（代表例）
    - `lemma S_nonneg_of_ge (hΛgt1 : 1 < Λ) (hn : 0 ≤ n) : 0 ≤ S Λ (n : ℤ)`
    - `lemma S_pos_of_nat_pos (hΛgt1 : 1 < Λ) (hn : 0 < n) : 0 < S Λ (n : ℤ)`
    - `lemma S_strict_mono_in_n (hΛgt1 : 1 < Λ) : StrictMono (fun n : ℕ => S Λ (n : ℤ))`（必要なら弱形）
- D2: Φ-数/二項（仮定付き）
  - 定義補助: `noncomputable abbrev phiNum (Λ : ℝ) (n : ℕ) := S Λ (n : ℤ) / S Λ 1`
  - 端点
    - `lemma phiBinom_zero (h : S Λ 1 ≠ 0) : phiBinom Λ n 0 = 1`
    - `lemma phiBinom_self (h : S Λ 1 ≠ 0) : phiBinom Λ n n = 1`
  - Pascal 型（候補）
    - `lemma phiBinom_succ (h : S Λ 1 ≠ 0) (hk : 0 < k ∧ k ≤ n+1) :
        phiBinom Λ (n+1) k
          = phiBinom Λ n k + ((S Λ (n+1 - k : ℕ) : ℝ) / (S Λ 1)) * phiBinom Λ n (k-1)`
    - 備考: 係数の形は q-二項に準じた Φ-版。厳密形は実装時に確認し、設計段階では「仮」と明記。
- D3: 高階 Leibniz（設計）
  - `theorem higher_leibniz (hΛ : 0 < Λ) (n : ℕ) (f g : ℝ → ℝ) :
      phiDiffIter Λ n (fun x => f x * g x)
        = fun x => ∑ k in Finset.range (n+1),
            (phiBinom Λ n k) *
            (∏ i in Finset.range n, (x * (Λ - 1/Λ))⁻¹) •
            (f (Λ^k * x) * g (x / Λ^(n-k)))`
  - 備考: 実装では分母の整理を個別化し、`field_simp` を避けるための補題化を進める。まずは n=0,1,2 あたりまでを証明し、一般 n は段階的に。

## 4. 実装手順（Tasks）

1) Hyperbolic 形の導入と補題整備（D1）
- `S_as_sinh` を追加。`zpow`→`Real.exp` 展開、`Real.sinh` の定義を使用。
- `S_nonneg_of_ge`/`S_pos_of_nat_pos` を `sinh` の単調性・`log Λ > 0` より導出。

2) Φ-数/二項の端点と（仮）Pascal 型再帰（D2）
- 端点は `phiFactorial` と `prod_range_succ` から簡潔に。
- 再帰は係数の形を設計通りの「候補」としてまず Statement 化（`TODO` 註記）、証明は仮定強め（例: `Λ > 1`、`S Λ 1 ≠ 0`、必要なら `phiFactorial ≠ 0`）で段階的に対応。

3) 高階 Leibniz（D3）
- まず `n=2` の形を証明（`phiDiff` を2回適用、分配で整理）。
- 補助: `pow_add`/`zpow_add₀`、`Finset` の sum/product 操作補題、`phiDiff_leibniz` の再利用。
- 一般 n はステートメントと帰納骨格の雛形を整え、十分な補題が揃ってから実施。

## 5. 依存関係と影響範囲

- 依存: `StructureSequence.lean` 既存 API、`PBWDistributivity` の分配補題は間接的に参考。
- 影響: 既存コードに破壊的変更なし。`@[simp]` の追加は限定的に行う。
- mathlib: `Real.sinh`, `Real.log`, `Real.exp`、`zpow` 補題群。

## 6. 受入基準（Acceptance Criteria）

- AC1: `S_as_sinh` と、その帰結としての基本不等式補題（代表例）が提供済み。
- AC2: `phiBinom` 端点補題（仮定付き）が提供済み。
- AC3: 高階 Leibniz の n=2 版が正しく証明済み、一般 n 版のステートメントが配置済み（仮定明記）。
- AC4: CI で既存ファイルとの整合が取れてビルド成功。

## 7. リスクと緩和

- R1: `S_as_sinh` 証明時の `zpow`/`Real.exp` の型・書換え煩雑
  - 緩和: 先に `Λ = Real.exp a` と置く方針の補題を用意し、`zpow` の加法則で組み立てる。
- R2: 高階 Leibniz の一般形が長大化
  - 緩和: n=2 までを確実に固め、以後は補助補題の拡充後に進める。
- R3: `phiBinom` 再帰の係数形が揺れる
  - 緩和: 設計段階では Statement を「候補」として明示し、証明段で係数を確定。

## 8. 命名規約とスタイル

- `S_*`, `phiDiff_*`, `phiFactorial_*`, `phiBinom_*` で統一。
- 仮定は引数前半に、`@[simp]` は有用な簡約に限定。
- 実数対数では `Λ > 0` を前提に置く。分母に `Λ - 1/Λ` が現れる箇所では `Λ ≠ 0 ∧ Λ ≠ 1/Λ` などを必要に応じて明記。

## 9. マイルストーン

- M1: D1（`S_as_sinh` と符号/単調系）完了
- M2: D2（端点補題、Pascal 候補の Statement）完了
- M3: D3（高階 Leibniz n=2 証明、一般形 Statement）完了

## 10. テストと検証

- 軽量 `example` を `StructureSequence.lean` 末尾に配置（`simp`・`linarith`・`norm_num` で検証可能な範囲）。
- 代表値チェック: `S_as_sinh` を使い `Λ = φ`、`n = 1,2` での整合例を追加（Examples でも可）。

## 11. 実装メモ

- `sinh` 展開
  ```lean
  have : 2 * Real.sinh t = Real.exp t - Real.exp (-t) := by
    simp [Real.sinh]
  ```
- `zpow` と `log/exp`
  ```lean
  -- Λ > 0 を仮定し、(Λ : ℝ)^m = Real.exp (m * Real.log Λ)
  -- と同値な補題を用意してから比較するのが安全。
  ```
- Leibniz の再帰
  ```lean
  -- phiDiffIter Λ (n+1) (f*g) = phiDiff Λ (phiDiffIter Λ n (f*g))
  -- を `phiDiff_leibniz` で都度展開し、分母を補題化して共通化。
  ```
