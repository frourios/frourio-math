# フルーリオ代数学 LEAN4実装 第3フェーズ設計書（P0 詳細）

バージョン: 1.0
対象期間: Phase P0（代数の土台仕上げ）
担当: 開発/形式化チーム

## 0. 目的とスコープ

- 目的: 交叉積と PBW 表現の核となる代数 API を安定化し、後続（Mellin 記号、Ore 交換式、解析）に必要な“正規形・分配・同一視”の事実を再利用可能な補題として整備する。
- スコープ: `Frourio/Algebra/CrossedProduct.lean` と `Frourio/Algebra/PBWDistributivity.lean` を中心に、PBWModule と CrossedProduct の相互運用 API を補強する。解析や幾何（EVI/Γ–Γ₂）は本設計の対象外。

## 1. 現状とギャップ

- 既存
  - `PBWModule`（= `((Fin m → ℤ) →₀ A)`）とねじれ畳み込み的な乗法 `PBWModule.mul`（σ 作用依存）。
  - 分配則系: `pbw_left_distrib`, `pbw_right_distrib`, 単項式積 `pbw_mul_single_single`。
  - CrossedProduct と Z^m 作用、`toZmActionOnFunctions`（関数上のスケール作用）。
  - CrossedProduct の素朴な積 `CrossedProduct.mul` とモノイド則（σ の公理から証明済）。
  - 片方向の埋め込み/抽出: `toPBW`, `fromPBW_of_eq_single` と往復補題。
- ギャップ
  - CrossedProduct ↔ PBW の準同型レベルの API が薄く、加法・乗法に関する自然性補題が未整理。
  - PBWModule.mul の結合律・単位元（存在すれば）に関する明示的補題がない（FrourioCrossedProduct では Mul 付与のみ）。
  - “正規形（単項式族の一意性）”を便利に使う射影/認識補題が不足。

## 2. 成果物（Deliverables）

- D1: CrossedProduct ↔ PBW の基本 API
  - `toPBW_add`: `toPBW (x + y) = toPBW x + toPBW y`
  - `toPBW_zero`: `toPBW 0 = 0`, `toPBW_neg`, `toPBW_sub`（必要なもの）
  - `toPBW_mul_single`/`single_mul_toPBW`: 片側が単項式のときの一致（σ を通した係数ねじれ）
  - `toPBW_mul`（条件付き）: `toPBW (x * y) = PBWModule.mul σ (toPBW x) (toPBW y)`（σ と CrossedProduct の積定義が整合する場合）
- D2: PBWModule の構造補強
  - `pbw_mul_assoc`: `(x ⊗ y) ⊗ z = x ⊗ (y ⊗ z)`（`⊗ = PBWModule.mul σ`）
  - `pbw_one` と左右単位性（定義可能な場合）。候補: `pbwOne := Finsupp.single 0 1`
  - 最低限、単項式レベルの結合律 `pbw_mul_single_single` を足場に、有限和に拡張する補題群
- D3: 正規形と同一性補題
  - `single_eq_single_iff`: `Finsupp.single v a = Finsupp.single w b ↔ v = w ∧ a = b`
  - `toPBW_injective_on_single`: CrossedProduct 単項式の注入性
  - `eq_of_toPBW_eq`: `toPBW x = toPBW y → x = y`（必要条件を明記。例えば単項式類に制限）
- D4: 文書化と実装ガイド
  - ファイル内セクションヘッダ、notation の指針、σ に関する注意点（`ZmAction` 公理依存）

## 3. 仕様（API と補題の型）

以下では `A : Type*`、`[Ring A]`、`m : ℕ`、`σ : ZmAction A m` を前提とする。

- CrossedProduct → PBW
  - `@[simp] lemma toPBW_zero : toPBW (A := A) (m := m) (0 : CrossedProduct A m) = 0`
  - `@[simp] lemma toPBW_add (x y) : toPBW (x + y) = toPBW x + toPBW y`
  - `@[simp] lemma toPBW_neg (x) : toPBW (-x) = - toPBW x`
  - `@[simp] lemma toPBW_sub (x y) : toPBW (x - y) = toPBW x - toPBW y`
- 片側単項式の積
  - `lemma toPBW_mul_single_right (x) (v a) :
      toPBW (CrossedProduct.mul σ x { base := a, scales := v })
        = PBWModule.mul σ (toPBW x) (Finsupp.single v a)`
  - 左側版も同様
- 両側積の整合
  - `lemma toPBW_mul (x y) :
      toPBW (CrossedProduct.mul σ x y)
        = PBWModule.mul σ (toPBW x) (toPBW y)`
    - 証明方針: `x` を単項式の有限和に分解して線形性＋`pbw_mul_single_single` を適用。
- PBWModule 構造
  - `lemma pbw_mul_assoc (x y z) :
      PBWModule.mul σ (PBWModule.mul σ x y) z
        = PBWModule.mul σ x (PBWModule.mul σ y z)`
    - 証明方針: `Finsupp.induction` による外側和の帰納＋`σ.act_add` と `σ.map_mul` の反復適用。
  - 単位元候補と性質（必要なら `pbwOne` を定義し、左・右単位を証明）。
- 正規形
  - `@[simp] lemma single_eq_single_iff {v w a b} :
      (Finsupp.single v a : PBWModule A m) = Finsupp.single w b ↔ v = w ∧ a = b`
  - `lemma toPBW_injective_on_monomial :
      fromPBW_of_eq_single (toPBW x = Finsupp.single v a) → x = { base := a, scales := v }`（適宜整理）

## 4. 実装手順（Tasks）

1) toPBW の加法・零・符号系補題（簡単）
- 場所: `Frourio/Algebra/CrossedProduct.lean`
- 技術: 展開して `Finsupp.single` の `simp` で終了

2) 片側単項式の積整合 → 両側積整合
- 先に右側単項式版を証明 → 左側も同様 → 任意の y を有限和へ（`Finsupp.induction`） → 一般形
- 依存: `pbw_mul_single_single`, `pbw_left_distrib`, `pbw_right_distrib`

3) PBWModule.mul の結合律/単位
- まず単項式×単項式×単項式で結合律を確認し、`Finsupp.induction` で拡張
- 単位元は `pbwOne := Finsupp.single (0 : Fin m → ℤ) (1 : A)` を候補に、左右単位を `sum` の性質で示す
- 注意: `σ.act_zero`, `σ.act_add`、および `map_one` を多用

4) 正規形補題群
- `single_eq_single_iff` は Finsupp の既存補題を活用しつつ補完
- CrossedProduct との往復で、単項式クラスに制限した注入性を整理

5) ドキュメント整備と `@[simp]` 属性
- 将来の書換えに効く箇所へ `@[simp]` を付与
- セクションコメントと注意点（σ の可換性でなく「作用」側での公理を使うこと）を明記

## 5. 依存関係と影響範囲

- 依存: 既存の `PBWDistributivity` の補題群、`ZmAction` の公理。
- 影響: 既存 API の互換性は維持。新規補題は後方互換。
- mathlib: 追加依存は不要（`Finsupp`, `Finset`, 基本代数）。

## 6. 受入基準（Acceptance Criteria）

- AC1: `toPBW` の加法・零・符号に関する補題が `simp` で使用可能。
- AC2: `toPBW_mul` が証明済み（σ と積の整合）。
- AC3: `PBWModule.mul` の結合律が証明済み（単位元は定義した場合、左右単位も）。
- AC4: 単項式正規形の同一性補題が提供され、CrossedProduct 単項式との往復が明示。
- AC5: 既存の例題・補題に破壊的変更なし（ビルドパス）。

## 7. リスクと緩和

- R1: `toPBW_mul` の一般形での証明が煩雑
  - 緩和: 片側単項式→有限和帰納のパターンをテンプレ化し、`simp` セットを強化
- R2: 単位元の選定（PBWModule.mul に自然単位がないシナリオ）
  - 緩和: 単位元はオプション扱い。必要なら FrourioCrossedProduct ラッパーに限定して導入

## 8. 命名規約とスタイル

- プレフィクス: `pbw_*`, `toPBW_*`, `crossed_*` を基本に一貫化。
- `@[simp]` は書換えで有益なものに限定。
- 1行証明は `simp`/`aesop` より `simp` を優先（依存の軽量化）。

## 9. 作業計画（Milestones）

- M1: D1（toPBW 加法系）完了
- M2: D2（PBWModule.mul 結合律）完了
- M3: D1（toPBW_mul）完了
- M4: D3（正規形）・文書整備完了

## 10. テストと検証

- 局所補題テスト: `#simp` と `example` を各ファイル末尾に軽量配置（CI 時間を圧迫しない範囲）。
- 将来的な `test/` 追加は P0 完了後に検討。

## 11. 実装メモ（参考）

- `Finsupp.induction` のスケルトン
  ```lean
  classical
  refine Finsupp.induction ?h0 ?hadd x
  · simp
  · intro v a s hvs ha0 ih
    simp [ih, Finsupp.sum_add_index, Finsupp.sum_single_index]
  ```
- σ の和法則
  ```lean
  have hσ := σ.act_add (v₁) (v₂) a
  -- act (v₁+v₂) a = act v₁ (act v₂ a)
  ```
- 片側単項式の積整合は `pbw_mul_single_single` を直接使用

以上により、P0 で必要な代数 API と補題群を確定し、後続フェーズの解析・極値性の基礎を安定化する。
