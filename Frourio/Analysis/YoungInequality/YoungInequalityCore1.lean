import Frourio.Analysis.HolderInequality.HolderInequality
import Frourio.Analysis.SchwartzDensityLp.MinkowskiIntegral
import Frourio.Analysis.SchwartzDensityLp.FubiniSection
import Frourio.Analysis.YoungInequality.YoungInequalityCore0
import Mathlib.Analysis.Convolution
import Mathlib.MeasureTheory.Function.LpSeminorm.Basic
import Mathlib.MeasureTheory.Group.Integral
import Mathlib.MeasureTheory.Integral.Bochner.Basic
import Mathlib.MeasureTheory.Integral.Bochner.L1
import Mathlib.MeasureTheory.Integral.Bochner.VitaliCaratheodory
import Mathlib.MeasureTheory.Measure.Haar.Basic

noncomputable section

open scoped BigOperators ENNReal Topology
open MeasureTheory Filter

variable {G Œ± : Type*}

section ConvolutionAuxiliary

variable {G : Type*}
variable [NormedAddCommGroup G] [MeasurableSpace G]
variable [MeasurableAdd‚ÇÇ G] [MeasurableNeg G]
variable (Œº : Measure G) [SFinite Œº] [Œº.IsAddRightInvariant] [Œº.IsNegInvariant]

lemma limsup_control_aux
    (Œº : Measure G) [SFinite Œº] (g_pow : G ‚Üí ‚Ñù‚â•0‚àû) (Œ¶ : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû)
    (f_seq : ‚Ñï ‚Üí G ‚Üí ‚Ñù‚â•0‚àû)
    (hŒ¶ : ‚àÄ N,
        Œ¶ N =
          ‚à´‚Åª x,
            f_seq N x ‚àÇ
              (‚àë k ‚àà Finset.range (N + 1), MeasureTheory.sfiniteSeq Œº k))
    (hf_meas : ‚àÄ N, AEMeasurable (f_seq N) Œº)
    (hf_mono : ‚àÄ·µê x ‚àÇ Œº, Monotone fun N => f_seq N x)
    (hf_tendsto : ‚àÄ·µê x ‚àÇ Œº, Tendsto (fun N => f_seq N x) atTop (ùìù (g_pow x))) :
    (‚à´‚Åª x, g_pow x ‚àÇ Œº) ‚â§ Filter.limsup Œ¶ Filter.atTop := by
  classical
  set Œºn : ‚Ñï ‚Üí Measure G := MeasureTheory.sfiniteSeq Œº
  set Œºpartial : ‚Ñï ‚Üí Measure G :=
    fun N => ‚àë k ‚àà Finset.range (N + 1), Œºn k
  have hŒº_sum : Measure.sum Œºn = Œº := MeasureTheory.sum_sfiniteSeq Œº
  have hŒºn_le : ‚àÄ k, Œºn k ‚â§ Œº :=
    fun k => MeasureTheory.sfiniteSeq_le (Œº := Œº) k
  have hŒºn_ac : ‚àÄ k, Œºn k ‚â™ Œº :=
    fun k => Measure.absolutelyContinuous_of_le (hŒºn_le k)
  have hŒ¶_sum :
      ‚àÄ N,
        Œ¶ N =
          ‚àë k ‚àà Finset.range (N + 1),
            ‚à´‚Åª x, f_seq N x ‚àÇ Œºn k := by
    intro N
    classical
    simpa [Œºn, Œºpartial, MeasureTheory.lintegral_finset_sum_measure]
      using hŒ¶ N
  let A : ‚Ñï ‚Üí ‚Ñï ‚Üí ‚Ñù‚â•0‚àû :=
    fun N k => ‚à´‚Åª x, f_seq N x ‚àÇ Œºn k
  let B : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû := fun k => ‚à´‚Åª x, g_pow x ‚àÇ Œºn k
  have hf_meas' : ‚àÄ k N, AEMeasurable (f_seq N) (Œºn k) := by
    intro k N
    exact (hf_meas N).mono_ac (hŒºn_ac k)
  have h_mono_zero :
      Œº {x | ¬¨ Monotone fun N => f_seq N x} = 0 := by
    simpa [ae_iff] using hf_mono
  have h_tendsto_zero :
      Œº {x |
          ¬¨ Tendsto (fun N => f_seq N x) atTop (ùìù (g_pow x))} = 0 := by
    simpa [ae_iff] using hf_tendsto
  have hf_mono_k :
      ‚àÄ k, ‚àÄ·µê x ‚àÇ Œºn k, Monotone fun N => f_seq N x := by
    intro k
    have h_le := hŒºn_le k
    have h_zero' :
        Œºn k {x | ¬¨ Monotone fun N => f_seq N x} = 0 := by
      have hineq := h_le {x | ¬¨ Monotone fun N => f_seq N x}
      have hle_zero :
          Œºn k {x | ¬¨ Monotone fun N => f_seq N x} ‚â§ 0 := by
        simpa [h_mono_zero] using hineq
      exact le_antisymm hle_zero bot_le
    exact (ae_iff).2 h_zero'
  have hf_tendsto_k :
      ‚àÄ k,
        ‚àÄ·µê x ‚àÇ Œºn k, Tendsto (fun N => f_seq N x) atTop (ùìù (g_pow x)) := by
    intro k
    have h_le := hŒºn_le k
    have h_zero' :
        Œºn k {x |
            ¬¨ Tendsto (fun N => f_seq N x) atTop (ùìù (g_pow x))} = 0 := by
      have hineq := h_le
          {x | ¬¨ Tendsto (fun N => f_seq N x) atTop (ùìù (g_pow x))}
      have hle_zero :
          Œºn k {x |
              ¬¨ Tendsto (fun N => f_seq N x) atTop (ùìù (g_pow x))} ‚â§ 0 := by
        simpa [h_tendsto_zero] using hineq
      exact le_antisymm hle_zero bot_le
    exact (ae_iff).2 h_zero'
  have hA_tendsto :
      ‚àÄ k, Tendsto (fun N => A N k) atTop (ùìù (B k)) := by
    intro k
    have :=
      MeasureTheory.lintegral_tendsto_of_tendsto_of_monotone
        (Œº := Œºn k)
        (f := fun N => f_seq N)
        (F := g_pow)
        (hf := hf_meas' k)
        (h_mono := hf_mono_k k)
        (h_tendsto := hf_tendsto_k k)
    simpa [A, B] using this
  have hA_mono :
      ‚àÄ k, Monotone fun N => A N k := by
    intro k
    refine fun i j hij =>
      lintegral_mono_ae <|
        (hf_mono_k k).mono ?_
    intro x hx
    exact hx hij
  have hŒ¶_le_limsup_partial :
      ‚àÄ J,
        (‚àë k ‚àà Finset.range (J + 1), B k) ‚â§
          Filter.limsup Œ¶ Filter.atTop := by
    intro J
    classical
    let SJ : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû :=
      fun N => ‚àë k ‚àà Finset.range (J + 1), A N k
    have h_eventually_le :
        ‚àÄ·∂† N in Filter.atTop, SJ N ‚â§ Œ¶ N := by
      refine (eventually_ge_atTop J).mono ?_
      intro N hNJ
      have h_subset :
          Finset.range (J + 1) ‚äÜ Finset.range (N + 1) := by
        intro k hk
        simp only [Finset.mem_range] at hk ‚ä¢
        -- hk : k < J + 1 means k ‚â§ J
        -- hNJ : J ‚â§ N, so k ‚â§ J ‚â§ N, thus k < N + 1
        calc k < J + 1 := hk
          _ ‚â§ N + 1 := Nat.succ_le_succ hNJ
      have h_nonneg :
          ‚àÄ i ‚àà Finset.range (N + 1), i ‚àâ Finset.range (J + 1) ‚Üí
            (0 : ‚Ñù‚â•0‚àû) ‚â§ A N i :=
        fun _ _ _ => bot_le
      have :
          SJ N ‚â§ ‚àë k ‚àà Finset.range (N + 1), A N k :=
        Finset.sum_le_sum_of_subset_of_nonneg h_subset h_nonneg
      simpa [SJ, hŒ¶_sum N] using this
    have hSJ_limsup_le :
        Filter.limsup SJ Filter.atTop ‚â§ Filter.limsup Œ¶ Filter.atTop :=
      Filter.limsup_le_limsup h_eventually_le
    have hSJ_tendsto :
        Tendsto SJ Filter.atTop (ùìù (‚àë k ‚àà Finset.range (J + 1), B k)) := by
      classical
      have h_tendsto_finset :
        ‚àÄ s : Finset ‚Ñï,
          Tendsto (fun N => ‚àë k ‚àà s, A N k) Filter.atTop
              (ùìù (‚àë k ‚àà s, B k)) := by
        intro s
        refine Finset.induction_on s ?base ?step
        ¬∑ simp
        ¬∑ intro a s ha h_ind
          have h_a := hA_tendsto a
          simpa [Finset.sum_insert, ha, add_comm, add_left_comm, add_assoc]
            using (h_a.add h_ind)
      simpa [SJ] using h_tendsto_finset (Finset.range (J + 1))
    have hSJ_limsup_eq :
        Filter.limsup SJ Filter.atTop =
          (‚àë k ‚àà Finset.range (J + 1), B k) :=
      hSJ_tendsto.limsup_eq
    -- Since SJ tends to its limit and limsup SJ ‚â§ limsup Œ¶
    calc (‚àë k ‚àà Finset.range (J + 1), B k)
      = limsup SJ atTop := hSJ_limsup_eq.symm
      _ ‚â§ limsup Œ¶ atTop := hSJ_limsup_le
  have h_tsum_eq :
      (‚àë' k, B k) = ‚à´‚Åª x, g_pow x ‚àÇ Œº := by
    classical
    simpa [B, Œºn, hŒº_sum] using
      (MeasureTheory.lintegral_sum_measure (Œº := Œºn) (f := g_pow)).symm
  have h_partial_sup :
      (‚àë' k, B k) =
        iSup (fun n => ‚àë k ‚àà Finset.range n, B k) := by
    simpa using (ENNReal.tsum_eq_iSup_nat (f := fun k => B k))
  have h_partial_le :
      (‚àë' k, B k) ‚â§ Filter.limsup Œ¶ Filter.atTop := by
    classical
    have h_sup_le :
        iSup (fun n => ‚àë k ‚àà Finset.range n, B k) ‚â§
          Filter.limsup Œ¶ Filter.atTop := by
      refine iSup_le ?_
      intro n
      cases n with
      | zero => simp
      | succ J => simpa [Nat.succ_eq_add_one] using hŒ¶_le_limsup_partial J
    simpa [h_partial_sup] using h_sup_le
  calc
    ‚à´‚Åª x, g_pow x ‚àÇ Œº = ‚àë' k, B k := h_tsum_eq.symm
    _ ‚â§ Filter.limsup Œ¶ Filter.atTop := h_partial_le

lemma limsup_rhs_aux
    (Œº : Measure G) [SFinite Œº] [Œº.IsAddRightInvariant] [Œº.IsNegInvariant]
    (f g : G ‚Üí ‚ÑÇ) (p q r : ‚Ñù‚â•0‚àû)
    (hp : 1 ‚â§ p) (hq : 1 ‚â§ q)
    (hpqr : 1 / p + 1 / q = 1 + 1 / r)
    (hr_ne_top : r ‚â† ‚àû)
    (hf : MemLp f p Œº) (hf_r : MemLp f r Œº) (hg : MemLp g q Œº)
    (Œ® : ‚Ñï ‚Üí ‚Ñù‚â•0‚àû)
    (hŒ® : ‚àÄ N, ‚àÉ (Œº' : Measure G), Œº' ‚â§ Œº ‚àß IsFiniteMeasure Œº' ‚àß
      Œ® N = (ENNReal.ofReal (‚à´ y, ‚Äñg y‚Äñ *
        (eLpNorm (fun x => f (x - y)) r Œº').toReal ‚àÇ Œº')) ^ r.toReal) :
    Filter.limsup Œ® Filter.atTop ‚â§
      (eLpNorm f p Œº * eLpNorm g q Œº) ^ r.toReal := by
  classical
  set C := (eLpNorm f p Œº * eLpNorm g q Œº) ^ r.toReal with hC_def
  have hŒ®_le : ‚àÄ N, Œ® N ‚â§ C := by
    intro N
    -- Get the specific measure Œº' for this N
    obtain ‚ü®Œº', hŒº'_le, hŒº'_fin, hŒ®N‚ü© := hŒ® N
    rw [hŒ®N, hC_def]
    have h_integrand_nonneg :
        0 ‚â§·µê[Œº'] fun y =>
            ‚Äñg y‚Äñ *
              (eLpNorm (fun x => f (x - y)) r Œº').toReal := by
      refine Filter.Eventually.of_forall ?_
      intro y
      have hg_nonneg : 0 ‚â§ ‚Äñg y‚Äñ := norm_nonneg _
      have hf_nonneg :
          0 ‚â§ (eLpNorm (fun x => f (x - y)) r Œº').toReal :=
        ENNReal.toReal_nonneg
      exact mul_nonneg hg_nonneg hf_nonneg
    have h_integral_nonneg :
        0 ‚â§
          ‚à´ y,
            ‚Äñg y‚Äñ *
              (eLpNorm (fun x => f (x - y)) r Œº').toReal ‚àÇ Œº' :=
      integral_nonneg_of_ae h_integrand_nonneg
    have h_eLp_le :
        ‚àÄ y,
          eLpNorm (fun x => f (x - y)) r Œº' ‚â§
            eLpNorm (fun x => f (x - y)) r Œº := by
      intro y
      exact
        eLpNorm_mono_measure
          (f := fun x => f (x - y))
          (Œº := Œº)
          (ŒΩ := Œº')
          (p := r)
          hŒº'_le
    have hf_aemeas : AEStronglyMeasurable f Œº :=
      hf.aestronglyMeasurable
    have h_translate :
        ‚àÄ y,
          eLpNorm (fun x => f (x - y)) r Œº = eLpNorm f r Œº := by
      intro y
      simpa [sub_eq_add_neg] using
        (eLpNorm_comp_add_right
          (Œº := Œº) (f := f) (y := -y) (p := r) hf_aemeas)
    have h_eLp_le_const :
        ‚àÄ y,
          eLpNorm (fun x => f (x - y)) r Œº' ‚â§ eLpNorm f r Œº := by
      intro y
      simpa [h_translate y] using h_eLp_le y
    have hg_mu' : MemLp g q Œº' := by
      have h_smul : (1 : ‚Ñù‚â•0‚àû) ‚Ä¢ Œº = Œº := by simp
      simpa [h_smul] using
        hg.of_measure_le_smul
          (Œº' := Œº')
          (c := (1 : ‚Ñù‚â•0‚àû))
          (by simp)
          (by simpa using hŒº'_le)
    sorry
  have h_cobounded :
      Filter.IsCoboundedUnder (¬∑ ‚â§ ¬∑) Filter.atTop Œ® := by
    refine
      Filter.isCoboundedUnder_le_of_eventually_le
        (x := (0 : ‚Ñù‚â•0‚àû)) (l := Filter.atTop) ?_
    simp
  have h_bound :=
    Filter.limsup_le_of_le (h := Filter.Eventually.of_forall hŒ®_le) (hf := h_cobounded)
  simpa [C, hC_def] using h_bound

lemma lintegral_convolution_norm_bound
    (Œº : Measure G) [SFinite Œº] [Œº.IsAddRightInvariant] [Œº.IsNegInvariant]
    (f g : G ‚Üí ‚ÑÇ) (p q r : ‚Ñù‚â•0‚àû)
    (hp : 1 ‚â§ p) (hq : 1 ‚â§ q)
    (hpqr : 1 / p + 1 / q = 1 + 1 / r)
    (hr_ne_top : r ‚â† ‚àû)
    (hf : MemLp f p Œº) (hf_r : MemLp f r Œº) (hg : MemLp g q Œº)
    (h_kernel_int :
      Integrable (fun q : G √ó G => f (q.1 - q.2) * g q.2) (Œº.prod Œº))
    (h_pointwise_piece :
      ‚àÄ N,
        (fun y =>
            (eLpNorm (fun x => f (x - y) * g y) r
              (‚àë k ‚àà Finset.range (N + 1), MeasureTheory.sfiniteSeq Œº k)).toReal)
          =·µê[‚àë k ‚àà Finset.range (N + 1), MeasureTheory.sfiniteSeq Œº k]
          fun y =>
            ‚Äñg y‚Äñ *
              (eLpNorm (fun x => f (x - y)) r
                (‚àë k ‚àà Finset.range (N + 1), MeasureTheory.sfiniteSeq Œº k)).toReal) :
    ‚à´‚Åª x, (ENNReal.ofReal (‚à´ y, ‚Äñf (x - y)‚Äñ * ‚Äñg y‚Äñ ‚àÇ Œº)) ^ r.toReal ‚àÇ Œº ‚â§
      (eLpNorm f p Œº * eLpNorm g q Œº) ^ r.toReal := by
  -- Start by extracting the exponent inequalities implied by `hp`, `hq`, and `hpqr`.
  have h_inv_p_le_one : p‚Åª¬π ‚â§ (1 : ‚Ñù‚â•0‚àû) := by
    simpa [one_div] using (ENNReal.inv_le_inv).2 hp
  have h_inv_q_le_one : q‚Åª¬π ‚â§ (1 : ‚Ñù‚â•0‚àû) := by
    simpa [one_div] using (ENNReal.inv_le_inv).2 hq
  have hpqr_inv : p‚Åª¬π + q‚Åª¬π = (1 : ‚Ñù‚â•0‚àû) + r‚Åª¬π := by
    simpa [one_div, add_comm, add_left_comm, add_assoc] using hpqr
  have h_sum_le_two : p‚Åª¬π + q‚Åª¬π ‚â§ (1 : ‚Ñù‚â•0‚àû) + 1 :=
    add_le_add h_inv_p_le_one h_inv_q_le_one
  have h_aux : (1 : ‚Ñù‚â•0‚àû) + r‚Åª¬π ‚â§ (1 : ‚Ñù‚â•0‚àû) + 1 := by
    simpa [hpqr_inv] using h_sum_le_two
  have h_inv_r_le_one : r‚Åª¬π ‚â§ (1 : ‚Ñù‚â•0‚àû) :=
    ENNReal.le_of_add_le_add_left (by simp) h_aux
  have hr : 1 ‚â§ r :=
    (ENNReal.inv_le_inv).1 <| by simpa [one_div] using h_inv_r_le_one
  have hr_pos : (0 : ‚Ñù‚â•0‚àû) < r := lt_of_lt_of_le (by simp) hr
  have hr_ne_zero : r ‚â† 0 := ne_of_gt hr_pos
  have hr_toReal_pos : 0 < r.toReal := ENNReal.toReal_pos hr_ne_zero hr_ne_top
  -- Record that none of the exponents are infinite; this will be crucial when we pass to real
  -- exponents via `toReal`.
  have hp_ne_top : p ‚â† ‚àû := by
    intro hp_top
    have h_eq : q‚Åª¬π = (1 : ‚Ñù‚â•0‚àû) + r‚Åª¬π := by
      simpa [hp_top, one_div, ENNReal.inv_top, zero_add, add_comm, add_left_comm, add_assoc]
        using hpqr
    have h_le_one : (1 : ‚Ñù‚â•0‚àû) + r‚Åª¬π ‚â§ 1 := by
      simpa [h_eq] using h_inv_q_le_one
    have h_le_one' : (1 : ‚Ñù‚â•0‚àû) + r‚Åª¬π ‚â§ (1 : ‚Ñù‚â•0‚àû) + 0 := by
      simpa using h_le_one
    have h_r_inv_le_zero : r‚Åª¬π ‚â§ (0 : ‚Ñù‚â•0‚àû) :=
      (ENNReal.add_le_add_iff_left (by simp)).1 h_le_one'
    have h_zero_le : (0 : ‚Ñù‚â•0‚àû) ‚â§ r‚Åª¬π := bot_le
    have h_r_inv_zero : r‚Åª¬π = 0 := le_antisymm h_r_inv_le_zero h_zero_le
    have hr_top : r = ‚àû := ENNReal.inv_eq_zero.1 h_r_inv_zero
    exact hr_ne_top hr_top
  have hq_ne_top : q ‚â† ‚àû := by
    intro hq_top
    have h_eq : p‚Åª¬π = (1 : ‚Ñù‚â•0‚àû) + r‚Åª¬π := by
      simpa [hq_top, one_div, ENNReal.inv_top, add_comm, add_left_comm, add_assoc]
        using hpqr
    have h_le_one : (1 : ‚Ñù‚â•0‚àû) + r‚Åª¬π ‚â§ 1 := by
      simpa [h_eq, add_comm] using h_inv_p_le_one
    have h_le_one' : (1 : ‚Ñù‚â•0‚àû) + r‚Åª¬π ‚â§ (1 : ‚Ñù‚â•0‚àû) + 0 := by
      simpa using h_le_one
    have h_r_inv_le_zero : r‚Åª¬π ‚â§ (0 : ‚Ñù‚â•0‚àû) :=
      (ENNReal.add_le_add_iff_left (by simp)).1 h_le_one'
    have h_zero_le : (0 : ‚Ñù‚â•0‚àû) ‚â§ r‚Åª¬π := bot_le
    have h_r_inv_zero : r‚Åª¬π = 0 := le_antisymm h_r_inv_le_zero h_zero_le
    have hr_top : r = ‚àû := ENNReal.inv_eq_zero.1 h_r_inv_zero
    exact hr_ne_top hr_top
  -- Switch to the real exponents, capturing the numerical relation provided by Young's hypothesis.
  set pr := ENNReal.toReal p with hpr
  set qr := ENNReal.toReal q with hqr
  set rr := ENNReal.toReal r with hrr
  have h_young_real :
      rr =
        (pr * qr) /
          (pr + qr - pr * qr) := by
    have :=
      young_exponent_relation
        (p := p) (q := q) (r := r)
        hp hq hr hpqr hp_ne_top hq_ne_top hr_ne_top
    simpa [hpr, hqr, hrr] using this

  -- Record the fibrewise integrability of the norm kernel; this will be used
  -- both to justify measurability statements and to ensure that the inner
  -- integral is finite for Œº-a.e. x.
  have h_section_int :
      ‚àÄ·µê x ‚àÇŒº, Integrable (fun y => ‚Äñf (x - y)‚Äñ * ‚Äñg y‚Äñ) Œº :=
    integrable_norm_convolution_kernel_section
      (Œº := Œº) (f := f) (g := g) h_kernel_int

  classical
  set H : G ‚Üí ‚Ñù := fun x => ‚à´ y, ‚Äñf (x - y)‚Äñ * ‚Äñg y‚Äñ ‚àÇ Œº
  have h_H_nonneg :
      ‚àÄ·µê x ‚àÇŒº, 0 ‚â§ H x := by
    refine h_section_int.mono ?_
    intro x _
    have h_nonneg_fun :
        0 ‚â§·µê[Œº] fun y => ‚Äñf (x - y)‚Äñ * ‚Äñg y‚Äñ :=
      Filter.Eventually.of_forall fun _ => mul_nonneg (norm_nonneg _) (norm_nonneg _)
    simpa [H] using integral_nonneg_of_ae h_nonneg_fun

  -- Exhaust the s-finite measure by finite pieces and record the basic properties
  set Œºn : ‚Ñï ‚Üí Measure G := MeasureTheory.sfiniteSeq Œº
  have hŒº_sum : Measure.sum Œºn = Œº := MeasureTheory.sum_sfiniteSeq Œº
  let Œºpartial : ‚Ñï ‚Üí Measure G := fun N => ‚àë k ‚àà Finset.range (N + 1), Œºn k
  have hŒºpartial_succ :
      ‚àÄ N, Œºpartial (N + 1) = Œºpartial N + Œºn (N + 1) := by
    intro N
    classical
    simp [Œºpartial, Nat.succ_eq_add_one, Finset.range_succ, add_comm, add_left_comm, add_assoc]
  have hŒºpartial_zero : Œºpartial 0 = Œºn 0 := by
    classical
    simp [Œºpartial]
  have hŒºn_le : ‚àÄ n, Œºn n ‚â§ Œº := fun n =>
    by
      simpa [Œºn] using MeasureTheory.sfiniteSeq_le (Œº := Œº) n
  have hŒºpartial_fin : ‚àÄ N, IsFiniteMeasure (Œºpartial N) := by
    intro N
    classical
    refine Nat.rec ?base ?step N
    ¬∑ simpa [Œºpartial] using (inferInstance : IsFiniteMeasure (Œºn 0))
    ¬∑ intro k hk
      have hk' : IsFiniteMeasure (Œºpartial k + Œºn (k + 1)) := by infer_instance
      simpa [hŒºpartial_succ, Nat.succ_eq_add_one] using hk'
  have hŒºpartial_le_succ : ‚àÄ N, Œºpartial N ‚â§ Œºpartial (N + 1) := by
    intro N s
    classical
    have hnonneg : 0 ‚â§ Œºn (N + 1) s := bot_le
    simp [hŒºpartial_succ, Nat.succ_eq_add_one, Measure.add_apply, hnonneg]
  have hŒºpartial_mono : Monotone Œºpartial :=
    monotone_nat_of_le_succ hŒºpartial_le_succ
  have hŒºpartial_le_smul :
      ‚àÄ N, Œºpartial N ‚â§ ((N + 1 : ‚Ñù‚â•0‚àû) ‚Ä¢ Œº) := by
    intro N
    simpa [Œºpartial] using (sfiniteSeq_partial_le_smul (Œº := Œº) N)
  have hŒºpartial_ac : ‚àÄ N, Œºpartial N ‚â™ Œº := by
    intro N
    exact Measure.absolutelyContinuous_of_le_smul (hŒºpartial_le_smul N)
  have hŒºpartial_tendsto :
      ‚àÄ ‚¶És : Set G‚¶Ñ, MeasurableSet s ‚Üí
        Tendsto (fun N => Œºpartial N s) atTop (ùìù (Œº s)) := by
    exact sfiniteSeq_partial_tendsto (Œº := Œº)
  have hŒºpartial_prod_le :
      ‚àÄ N,
        (Œºpartial N).prod (Œºpartial N) ‚â§
          (((N + 1 : ‚Ñù‚â•0‚àû) * (N + 1 : ‚Ñù‚â•0‚àû)) ‚Ä¢ (Œº.prod Œº)) := by
    intro N
    simpa [Œºpartial, Œºn]
      using (sfiniteSeq_partial_prod_le_smul (Œº := Œº) N)
  have hŒºpartial_prod_ac :
      ‚àÄ N, (Œºpartial N).prod (Œºpartial N) ‚â™ Œº.prod Œº := by
    intro N
    exact Measure.absolutelyContinuous_of_le_smul (hŒºpartial_prod_le N)
  have hf_partial : ‚àÄ N, MemLp f p (Œºpartial N) := by
    intro N
    refine hf.of_measure_le_smul (Œº' := Œºpartial N) (c := (N + 1 : ‚Ñù‚â•0‚àû)) ?_ ?_
    ¬∑ simp [Nat.succ_eq_add_one]
    ¬∑ simpa using hŒºpartial_le_smul N
  have hf_r_partial : ‚àÄ N, MemLp f r (Œºpartial N) := by
    intro N
    refine hf_r.of_measure_le_smul (Œº' := Œºpartial N) (c := (N + 1 : ‚Ñù‚â•0‚àû)) ?_ ?_
    ¬∑ simp [Nat.succ_eq_add_one]
    ¬∑ simpa using hŒºpartial_le_smul N
  have h_translate_norm_bound :
      ‚àÄ N y,
        eLpNorm (fun x => f (x - y)) r (Œºpartial N) ‚â§
          ((N + 1 : ‚Ñù‚â•0‚àû) ^ (1 / r).toReal) * eLpNorm f r Œº := by
    intro N y
    exact
      sfiniteSeq_partial_translate_norm_bound
        (Œº := Œº)
        (f := f)
        (Œºpartial := Œºpartial)
        (hf := hf_r)
        (h_le := hŒºpartial_le_smul)
        N y
  have h_translate_norm_bound_toReal :
      ‚àÄ N y,
        (eLpNorm (fun x => f (x - y)) r (Œºpartial N)).toReal ‚â§
          ((N + 1 : ‚Ñù‚â•0‚àû) ^ (1 / r).toReal * eLpNorm f r Œº).toReal := by
    intro N y
    have h_bound := h_translate_norm_bound N y
    have h_pow_ne_top :
        ((N + 1 : ‚Ñù‚â•0‚àû) ^ (1 / r).toReal) ‚â† ‚àû := by
      have h_exp_nonneg : 0 ‚â§ (1 / r).toReal := by simp [one_div]
      exact ENNReal.rpow_ne_top_of_nonneg h_exp_nonneg (by simp)
    have h_const_ne_top :
        ((N + 1 : ‚Ñù‚â•0‚àû) ^ (1 / r).toReal * eLpNorm f r Œº) ‚â† ‚àû :=
      ENNReal.mul_ne_top h_pow_ne_top hf_r.eLpNorm_ne_top
    exact ENNReal.toReal_mono h_const_ne_top h_bound
  have hg_partial : ‚àÄ N, MemLp g q (Œºpartial N) := by
    intro N
    refine hg.of_measure_le_smul (Œº' := Œºpartial N) (c := (N + 1 : ‚Ñù‚â•0‚àû)) ?_ ?_
    ¬∑ simp [Nat.succ_eq_add_one]
    ¬∑ simpa using hŒºpartial_le_smul N
  have h_pointwise_piece_partial :
      ‚àÄ N,
        (fun y =>
            (eLpNorm (fun x => f (x - y) * g y) r (Œºpartial N)).toReal)
          =·µê[Œºpartial N]
          fun y =>
            ‚Äñg y‚Äñ *
              (eLpNorm (fun x => f (x - y)) r (Œºpartial N)).toReal := by
    intro N
    simpa [Œºpartial, Œºn] using h_pointwise_piece N
  have hg_partial_one : ‚àÄ N, MemLp g 1 (Œºpartial N) := by
    intro N
    exact (hg_partial N).mono_exponent (p := (1 : ‚Ñù‚â•0‚àû)) (q := q) hq
  have hg_partial_int : ‚àÄ N, Integrable g (Œºpartial N) := by
    intro N
    exact (memLp_one_iff_integrable).1 (hg_partial_one N)

  -- Preparatory bounds for the finite-measure pieces
  have h_kernel_int_partial :
      ‚àÄ N,
        Integrable (fun q : G √ó G => f (q.1 - q.2) * g q.2)
          ((Œºpartial N).prod (Œºpartial N)) := by
    intro N
    classical
    have h_const_ne_top :
        ((N + 1 : ‚Ñù‚â•0‚àû) * (N + 1 : ‚Ñù‚â•0‚àû)) ‚â† ‚àû := by
      simpa using
        ENNReal.mul_ne_top (by simp) (by simp)
    refine
      Integrable.of_measure_le_smul
        (Œº := Œº.prod Œº)
        (Œº' := (Œºpartial N).prod (Œºpartial N))
        (f := fun q : G √ó G => f (q.1 - q.2) * g q.2)
        h_const_ne_top (hŒºpartial_prod_le N) ?_
    simpa using h_kernel_int

  have h_kernel_meas_partial :
      ‚àÄ N,
        AEStronglyMeasurable
          (fun q : G √ó G => f (q.1 - q.2) * g q.2)
          ((Œºpartial N).prod (Œºpartial N)) := by
    intro N
    exact
      (h_kernel_int.aestronglyMeasurable.mono_ac (hŒºpartial_prod_ac N))

  have h_kernel_fiber_int_partial :
      ‚àÄ N, ‚àÄ·µê x ‚àÇ Œºpartial N,
        Integrable (fun y => f (x - y) * g y) (Œºpartial N) := by
    intro N
    have h :=
      Integrable.prod_right_ae
        (Œº := Œºpartial N) (ŒΩ := Œºpartial N)
        (h_kernel_int_partial N)
    refine h.mono ?_
    intro x hx
    simpa [sub_eq_add_neg] using hx

  have hŒºpartial_def :
      ‚àÄ N, Œºpartial N = ‚àë k ‚àà Finset.range (N + 1), Œºn k := fun _ => rfl

  have hŒºpartial_le :
      ‚àÄ N, Œºpartial N ‚â§ Œº :=
    sfiniteSeq_partial_le_measure
      (Œº := Œº)
      (Œºn := Œºn)
      (Œºpartial := Œºpartial)
      (hŒº_sum := hŒº_sum)
      (hŒºpartial_def := hŒºpartial_def)

  classical
  let Hpartial : ‚Ñï ‚Üí G ‚Üí ‚Ñù :=
    fun N x => ‚à´ y, ‚Äñf (x - y)‚Äñ * ‚Äñg y‚Äñ ‚àÇ Œºpartial N

  have h_integrability_all :
      ‚àÄ·µê x ‚àÇ Œº,
        Integrable (fun y => ‚Äñf (x - y)‚Äñ * ‚Äñg y‚Äñ) Œº ‚àß
          ‚àÄ N,
            Integrable (fun y => ‚Äñf (x - y)‚Äñ * ‚Äñg y‚Äñ) (Œºpartial N) := by
    refine h_section_int.mono ?_
    intro x hx
    refine ‚ü®hx, ?_‚ü©
    intro N
    have h_const_ne_top :
        ((N + 1 : ‚Ñù‚â•0‚àû)) ‚â† ‚àû := by simp
    exact
      Integrable.of_measure_le_smul
        (Œº := Œº) (Œº' := Œºpartial N)
        (f := fun y => ‚Äñf (x - y)‚Äñ * ‚Äñg y‚Äñ)
        h_const_ne_top
        (hŒºpartial_le_smul N)
        hx

  have h_Hpartial_mono :
      ‚àÄ·µê x ‚àÇ Œº, Monotone fun N => Hpartial N x := by
    refine h_integrability_all.mono ?_
    intro x hx
    rcases hx with ‚ü®hxŒº, hx_partial‚ü©
    intro N M hNM
    have h_meas_le : Œºpartial N ‚â§ Œºpartial M := hŒºpartial_mono hNM
    haveI : IsFiniteMeasure (Œºpartial N) := hŒºpartial_fin N
    haveI : IsFiniteMeasure (Œºpartial M) := hŒºpartial_fin M
    exact
      integral_norm_mul_mono
        (Œº‚ÇÅ := Œºpartial N) (Œº‚ÇÇ := Œºpartial M)
        f g x h_meas_le (hx_partial M)

  have h_Hpartial_le_H :
      ‚àÄ·µê x ‚àÇ Œº, ‚àÄ N, Hpartial N x ‚â§ H x := by
    refine h_integrability_all.mono ?_
    intro x hx
    rcases hx with ‚ü®hxŒº, hx_partial‚ü©
    intro N
    have h_meas_le : Œºpartial N ‚â§ Œº := hŒºpartial_le N
    haveI : IsFiniteMeasure (Œºpartial N) := hŒºpartial_fin N
    exact
      integral_norm_mul_mono
        (Œº‚ÇÅ := Œºpartial N) (Œº‚ÇÇ := Œº)
        f g x h_meas_le hxŒº

  have h_Hpartial_tendsto :
      ‚àÄ·µê x ‚àÇ Œº, Tendsto (fun N => Hpartial N x) atTop (ùìù (H x)) := by
    refine h_integrability_all.mono ?_
    intro x hx
    classical
    rcases hx with ‚ü®hxŒº, hx_partial‚ü©
    set hxFun : G ‚Üí ‚Ñù := fun y => ‚Äñf (x - y)‚Äñ * ‚Äñg y‚Äñ with hxFun_def
    have hxŒº_int : Integrable hxFun Œº := by
      simpa [hxFun_def] using hxŒº
    have hx_partial_int :
        ‚àÄ N, Integrable hxFun (Œºpartial N) := by
      intro N
      have := hx_partial N
      simpa [hxFun_def] using this
    have hx_piece_int :
        ‚àÄ n, Integrable hxFun (Œºn n) := by
      intro n
      refine hxŒº_int.of_measure_le_smul (Œº := Œº) (Œº' := Œºn n)
          (c := (1 : ‚Ñù‚â•0‚àû)) ?_ ?_
      ¬∑ simp
      ¬∑ simpa [Œºn, one_smul] using MeasureTheory.sfiniteSeq_le (Œº := Œº) n
    have hx_Hpartial_def :
        ‚àÄ N, Hpartial N x = ‚à´ y, hxFun y ‚àÇ Œºpartial N := by
      intro N
      simp [Hpartial, hxFun_def]
    have hx_H_def : H x = ‚à´ y, hxFun y ‚àÇ Œº := by
      simp [H, hxFun_def]
    have hx_Hpartial_succ :
        ‚àÄ N,
          Hpartial (N + 1) x =
            Hpartial N x + ‚à´ y, hxFun y ‚àÇ Œºn (N + 1) := by
      intro N
      have hx_add :=
        MeasureTheory.integral_add_measure
          (Œº := Œºpartial N) (ŒΩ := Œºn (N + 1))
          (f := hxFun)
          (hx_partial_int N)
          (hx_piece_int (N + 1))
      simpa [hx_Hpartial_def, hxFun_def, hŒºpartial_succ,
        Nat.succ_eq_add_one, add_comm, add_left_comm, add_assoc]
        using hx_add
    have hx_Hpartial_sum :
        ‚àÄ N,
          Hpartial N x =
            ‚àë k ‚àà Finset.range (N + 1),
              ‚à´ y, hxFun y ‚àÇ Œºn k := by
      intro N
      induction' N with N hN
      ¬∑ simp [hx_Hpartial_def, hxFun_def, Œºpartial, hŒºpartial_zero,
          Finset.range_one]
      ¬∑ have hx_step := hx_Hpartial_succ N
        calc
          Hpartial (N + 1) x
              = Hpartial N x + ‚à´ y, hxFun y ‚àÇ Œºn (N + 1) := hx_step
          _ = (‚àë k ‚àà Finset.range (N + 1), ‚à´ y, hxFun y ‚àÇ Œºn k)
                + ‚à´ y, hxFun y ‚àÇ Œºn (N + 1) := by simp [hN]
          _ = ‚àë k ‚àà Finset.range (N + 1 + 1), ‚à´ y, hxFun y ‚àÇ Œºn k := by
                simp [Finset.sum_range_succ, Nat.succ_eq_add_one, add_comm,
                  add_left_comm, add_assoc]
    have hx_hasSum :
        HasSum (fun n => ‚à´ y, hxFun y ‚àÇ Œºn n)
          (‚à´ y, hxFun y ‚àÇ Œº) := by
      have hx_int_sum : Integrable hxFun (Measure.sum Œºn) := by
        simpa [hxFun_def, hŒº_sum] using hxŒº_int
      have hx_hasSum_aux :=
        MeasureTheory.hasSum_integral_measure
          (Œº := Œºn) (f := hxFun) (hf := hx_int_sum)
      simpa [hxFun_def, hŒº_sum]
        using hx_hasSum_aux
    have hx_tendsto_range :
        Tendsto (fun N => ‚àë k ‚àà Finset.range N, ‚à´ y, hxFun y ‚àÇ Œºn k)
          atTop (ùìù (‚à´ y, hxFun y ‚àÇ Œº)) :=
      hx_hasSum.tendsto_sum_nat
    have hx_tendsto :
        Tendsto (fun N => ‚àë k ‚àà Finset.range (N + 1),
            ‚à´ y, hxFun y ‚àÇ Œºn k) atTop (ùìù (‚à´ y, hxFun y ‚àÇ Œº)) :=
      hx_tendsto_range.comp (tendsto_add_atTop_nat 1)
    have hx_eventually :
        (fun N =>
            ‚àë k ‚àà Finset.range (N + 1),
              ‚à´ y, hxFun y ‚àÇ Œºn k)
          =·∂†[Filter.atTop]
            fun N => Hpartial N x :=
      Filter.Eventually.of_forall fun N => (hx_Hpartial_sum N).symm
    have hx_tendsto_Hpartial :
        Tendsto (fun N => Hpartial N x) atTop
          (ùìù (‚à´ y, hxFun y ‚àÇ Œº)) :=
      hx_tendsto.congr' hx_eventually
    simpa [hx_H_def] using hx_tendsto_Hpartial
  -- Step 4: promote the pointwise convergence information to the `L^r` framework via
  -- measurability and lintegral convergence statements.
  have h_H_pow_eq :
      ‚àÄ·µê x ‚àÇ Œº,
        ‚ÄñH x‚Äñ‚Çë ^ r.toReal = (ENNReal.ofReal (H x)) ^ r.toReal := by
    refine h_H_nonneg.mono ?_
    intro x hx
    have hx_abs : ENNReal.ofReal ‚ÄñH x‚Äñ = ENNReal.ofReal (H x) := by
      simp [Real.norm_eq_abs, abs_of_nonneg hx]
    have hx_pow := congrArg (fun t : ‚Ñù‚â•0‚àû => t ^ r.toReal) hx_abs
    have hx_coe : ‚ÄñH x‚Äñ‚Çë = ENNReal.ofReal ‚ÄñH x‚Äñ := by
      simpa using (ofReal_norm_eq_enorm (H x)).symm
    simp [hx_coe, Real.norm_eq_abs, abs_of_nonneg hx]
  have h_H_lintegral_eq :
      ‚à´‚Åª x, ‚ÄñH x‚Äñ‚Çë ^ r.toReal ‚àÇ Œº
        = ‚à´‚Åª x, (ENNReal.ofReal (H x)) ^ r.toReal ‚àÇ Œº := by
    refine lintegral_congr_ae h_H_pow_eq
  have h_eLpNorm_H :=
    eLpNorm_eq_lintegral_rpow_enorm (Œº := Œº) (f := H) hr_ne_zero hr_ne_top
  have h_eLpNorm' :
      eLpNorm H r Œº =
        (‚à´‚Åª x, ‚ÄñH x‚Äñ‚Çë ^ r.toReal ‚àÇ Œº) ^ r.toReal‚Åª¬π := by
    simpa [one_div] using h_eLpNorm_H
  have hr_toReal_pos' : 0 < r.toReal :=
    ENNReal.toReal_pos hr_ne_zero hr_ne_top
  have h_H_lintegral_repr :
      (eLpNorm H r Œº) ^ r.toReal
        = ‚à´‚Åª x, (ENNReal.ofReal (H x)) ^ r.toReal ‚àÇ Œº := by
    have h_nonzero : r.toReal ‚â† 0 := ne_of_gt hr_toReal_pos'
    have h_mul : r.toReal‚Åª¬π * r.toReal = 1 := by
      simp [one_div, h_nonzero]
    have h_pow :=
      congrArg (fun t : ‚Ñù‚â•0‚àû => t ^ r.toReal) h_eLpNorm'
    have h_rhs :
        ((‚à´‚Åª x, ‚ÄñH x‚Äñ‚Çë ^ r.toReal ‚àÇ Œº) ^ r.toReal‚Åª¬π) ^ r.toReal
          = ‚à´‚Åª x, ‚ÄñH x‚Äñ‚Çë ^ r.toReal ‚àÇ Œº := by
      simpa [ENNReal.rpow_mul, h_mul]
        using
          (ENNReal.rpow_mul
            (‚à´‚Åª x, ‚ÄñH x‚Äñ‚Çë ^ r.toReal ‚àÇ Œº)
            r.toReal‚Åª¬π
            r.toReal).symm
    have h_repr := h_pow.trans h_rhs
    simpa [h_H_lintegral_eq] using h_repr
  have h_kernel_norm_meas :
      AEStronglyMeasurable
        (fun q : G √ó G => ‚Äñf (q.1 - q.2) * g q.2‚Äñ) (Œº.prod Œº) :=
    (convolution_kernel_aestronglyMeasurable (Œº := Œº)
      (f := f) (g := g) hf.aestronglyMeasurable hg.aestronglyMeasurable).norm
  have h_kernel_norm_meas_partial :
      ‚àÄ N,
        AEStronglyMeasurable
          (fun q : G √ó G => ‚Äñf (q.1 - q.2) * g q.2‚Äñ)
          (Œº.prod (Œºpartial N)) := by
    intro N
    have h_ac : Œº.prod (Œºpartial N) ‚â™ Œº.prod Œº :=
      Measure.AbsolutelyContinuous.rfl.prod (hŒºpartial_ac N)
    exact (h_kernel_norm_meas.mono_ac h_ac)
  have h_H_meas : AEStronglyMeasurable H Œº := by
    simpa [H, norm_mul, mul_comm, mul_left_comm, mul_assoc]
      using h_kernel_norm_meas.integral_prod_right'
  have h_Hpartial_meas :
      ‚àÄ N, AEStronglyMeasurable (fun x => Hpartial N x) Œº := by
    intro N
    simpa [Hpartial, norm_mul, mul_comm, mul_left_comm, mul_assoc]
      using (h_kernel_norm_meas_partial N).integral_prod_right'
  have h_H_pow_meas :
      AEMeasurable (fun x => (ENNReal.ofReal (H x)) ^ r.toReal) Œº := by
    have h_ofReal :
        AEMeasurable (fun x => ENNReal.ofReal (H x)) Œº :=
      ENNReal.measurable_ofReal.comp_aemeasurable h_H_meas.aemeasurable
    exact
      (ENNReal.continuous_rpow_const.measurable.comp_aemeasurable h_ofReal)
  have h_Hpartial_pow_meas :
      ‚àÄ N,
        AEMeasurable (fun x => (ENNReal.ofReal (Hpartial N x)) ^ r.toReal) Œº := by
    intro N
    have h_ofReal :
        AEMeasurable (fun x => ENNReal.ofReal (Hpartial N x)) Œº :=
      ENNReal.measurable_ofReal.comp_aemeasurable (h_Hpartial_meas N).aemeasurable
    exact
      (ENNReal.continuous_rpow_const.measurable.comp_aemeasurable h_ofReal)
  have h_Hpartial_nonneg :
      ‚àÄ·µê x ‚àÇ Œº, ‚àÄ N, 0 ‚â§ Hpartial N x := by
    refine h_integrability_all.mono ?_
    intro x hx
    rcases hx with ‚ü®hxŒº, hx_partial‚ü©
    intro N
    have h_nonneg_fun :
        0 ‚â§·µê[Œºpartial N] fun y => ‚Äñf (x - y)‚Äñ * ‚Äñg y‚Äñ :=
      Filter.Eventually.of_forall fun _ => mul_nonneg (norm_nonneg _) (norm_nonneg _)
    have h_nonneg :=
      integral_nonneg_of_ae (Œº := Œºpartial N) (f := fun y => ‚Äñf (x - y)‚Äñ * ‚Äñg y‚Äñ) h_nonneg_fun
    simpa [Hpartial] using h_nonneg
  have h_Hpartial_pow_mono :
      ‚àÄ·µê x ‚àÇ Œº,
        Monotone fun N =>
          (ENNReal.ofReal (Hpartial N x)) ^ r.toReal := by
    refine (h_Hpartial_mono.and h_Hpartial_nonneg).mono ?_
    intro x hx
    rcases hx with ‚ü®h_mono, -‚ü©
    intro N M hNM
    have h_le := ENNReal.ofReal_le_ofReal (h_mono hNM)
    exact ENNReal.rpow_le_rpow h_le (by have := ENNReal.toReal_nonneg (a := r); simp)
  have h_Hpartial_pow_tendsto :
      ‚àÄ·µê x ‚àÇ Œº,
        Tendsto (fun N => (ENNReal.ofReal (Hpartial N x)) ^ r.toReal) atTop
          (ùìù ((ENNReal.ofReal (H x)) ^ r.toReal)) := by
    refine (h_Hpartial_tendsto.and h_H_nonneg).mono ?_
    intro x hx
    rcases hx with ‚ü®hx_tendsto, -‚ü©
    have h_ofReal_tendsto :
        Tendsto (fun N => ENNReal.ofReal (Hpartial N x)) atTop
          (ùìù (ENNReal.ofReal (H x))) :=
      (ENNReal.continuous_ofReal.continuousAt.tendsto).comp hx_tendsto
    have h_pow_tendsto :
        Tendsto (fun N => (ENNReal.ofReal (Hpartial N x)) ^ r.toReal) atTop
          (ùìù ((ENNReal.ofReal (H x)) ^ r.toReal)) :=
      (ENNReal.continuous_rpow_const.tendsto _).comp h_ofReal_tendsto
    simpa using h_pow_tendsto
  let g_pow : G ‚Üí ‚Ñù‚â•0‚àû := fun x => (ENNReal.ofReal (H x)) ^ r.toReal
  have h_lintegral_Hpartial_partial :
      ‚àÄ N,
        ‚à´‚Åª x, g_pow x ‚àÇ Œºpartial N =
          ‚àë k ‚àà Finset.range (N + 1),
            ‚à´‚Åª x, g_pow x ‚àÇ Œºn k := by
    intro N
    classical
    simp [g_pow, Œºpartial]
  have h_lintegral_Hpartial_sum :
      (‚àë' k, ‚à´‚Åª x, g_pow x ‚àÇ Œºn k) = ‚à´‚Åª x, g_pow x ‚àÇ Œº := by
    classical
    simpa [g_pow, hŒº_sum]
      using
        (MeasureTheory.lintegral_sum_measure
          (Œº := Œºn)
          (f := fun x : G => g_pow x)).symm
  have h_lintegral_Hpartial_mono :
      Monotone (fun N => ‚à´‚Åª x, g_pow x ‚àÇ Œºpartial N) := by
    intro N M hNM
    exact lintegral_mono' (hŒºpartial_mono hNM) fun _ => le_rfl
  have h_lintegral_Hpartial_tendsto :
      Tendsto (fun N => ‚à´‚Åª x, g_pow x ‚àÇ Œºpartial N) atTop
        (ùìù (‚à´‚Åª x, g_pow x ‚àÇ Œº)) := by
    classical
    have h_series_tendsto :
        Tendsto
          (fun N =>
            ‚àë k ‚àà Finset.range (N + 1),
              ‚à´‚Åª x, g_pow x ‚àÇ Œºn k)
          atTop
          (ùìù (‚àë' k, ‚à´‚Åª x, g_pow x ‚àÇ Œºn k)) := by
      exact
        (ENNReal.tendsto_nat_tsum
          (f := fun k => ‚à´‚Åª x, g_pow x ‚àÇ Œºn k)).comp
          (tendsto_add_atTop_nat 1)
    have h_eval :
        (fun N => ‚à´‚Åª x, g_pow x ‚àÇ Œºpartial N)
          = fun N =>
              ‚àë k ‚àà Finset.range (N + 1),
                ‚à´‚Åª x, g_pow x ‚àÇ Œºn k := by
      funext N
      exact h_lintegral_Hpartial_partial N
    have h_eval' :
        (‚àë' k, ‚à´‚Åª x, g_pow x ‚àÇ Œºn k)
          = ‚à´‚Åª x, g_pow x ‚àÇ Œº :=
      h_lintegral_Hpartial_sum
    simpa [h_eval, h_eval'] using h_series_tendsto
  -- Step 5: apply the finite-measure Minkowski inequality to each truncated measure and
  -- translate the resulting estimate into an `L^r` bound.
  have h_kernel_int_piece :
      ‚àÄ N,
        Integrable
          (fun q : G √ó G => f (q.1 - q.2) * g q.2) ((Œºpartial N).prod (Œºpartial N)) := by
    simpa using h_kernel_int_partial
  have h_kernel_meas_piece :
      ‚àÄ N,
        AEStronglyMeasurable
          (fun q : G √ó G => f (q.1 - q.2) * g q.2)
          ((Œºpartial N).prod (Œºpartial N)) := by
    intro N
    exact h_kernel_meas_partial N
  have h_kernel_fiber_int_piece :
      ‚àÄ N, ‚àÄ·µê y ‚àÇ Œºpartial N,
        Integrable (fun x => f (x - y) * g y) (Œºpartial N) := by
    intro N
    have h :=
      Integrable.prod_left_ae (Œº := Œºpartial N) (ŒΩ := Œºpartial N)
        (h_kernel_int_partial N)
    refine h.mono ?_
    intro y hy
    simpa [sub_eq_add_neg] using hy
  have h_kernel_fiber_mem_piece :
      ‚àÄ N, ‚àÄ·µê y ‚àÇ Œºpartial N,
        MemLp (fun x => f (x - y) * g y) r (Œºpartial N) := by
    intro N
    have h :=
      convolution_kernel_fiber_memLp_of_memLp (Œº := Œº)
        (p := r) (q := q) hf_r hg
    have h_dom :
        ‚àÄ·µê y ‚àÇ Œº,
          MemLp (fun x => f (x - y) * g y) r (Œºpartial N) := by
      refine h.mono ?_
      intro y hy
      refine hy.of_measure_le_smul (Œº' := Œºpartial N) (c := (N + 1 : ‚Ñù‚â•0‚àû)) ?_ ?_
      ¬∑ simp [Nat.succ_eq_add_one]
      ¬∑ simpa using hŒºpartial_le_smul N
    have h_zero :=
      (ae_iff).1 h_dom
    have h_zero' :=
      (hŒºpartial_ac N) h_zero
    exact (ae_iff).2 <| by
      simpa using h_zero'
  have h_norm_piece :
      ‚àÄ N,
        Integrable
          (fun y =>
              ‚Äñg y‚Äñ *
                (eLpNorm (fun x => f (x - y)) r (Œºpartial N)).toReal)
          (Œºpartial N) := by
    intro N
    exact
      sfiniteSeq_partial_integrable_norm_mul
        (Œº := Œº)
        (hr := hr)
        (hr_ne_top := hr_ne_top)
        (f := f)
        (g := g)
        (Œºpartial := Œºpartial)
        (hf := hf_r)
        (hg_partial_int := hg_partial_int)
        (hŒºpartial_fin := hŒºpartial_fin)
        (hŒºpartial_prod_ac := hŒºpartial_prod_ac)
        (h_translate_norm_bound_toReal := h_translate_norm_bound_toReal)
        N
  have h_convPiece_def :
      ‚àÄ N,
        (fun x => ‚à´ y, f (x - y) * g y ‚àÇ Œºpartial N)
          = fun x => ‚à´ y, f (x - y) * g y ‚àÇ Œºpartial N := by
    intro N; rfl
  have h_conv_piece_bound :
      ‚àÄ N,
        eLpNorm
            (fun x => ‚à´ y, f (x - y) * g y ‚àÇ Œºpartial N) r (Œºpartial N)
          ‚â§
        ENNReal.ofReal
          (‚à´ y, ‚Äñg y‚Äñ *
              (eLpNorm (fun x => f (x - y)) r (Œºpartial N)).toReal ‚àÇ Œºpartial N) := by
    intro N
    have h_minkowski :=
      minkowski_inequality_convolution_complex
        (Œº := Œºpartial N)
        (f := f) (g := g) (p := r)
        hr hr_ne_top
        (h_kernel_meas_piece N)
        (h_kernel_int_piece N)
        (h_kernel_fiber_int_piece N)
        (h_kernel_fiber_mem_piece N)
        (h_norm_piece N)
    simpa [h_convPiece_def N, sub_eq_add_neg,
      integral_congr_ae (h_pointwise_piece_partial N)]
      using h_minkowski
  -- Translate the previous `L^r` bound into a bound on the lintegral of the truncated
  -- Lemma: For complex-valued functions, eLpNorm of the norm equals eLpNorm of the function
  have eLpNorm_norm_eq_of_complex {Œº' : Measure G} (h : G ‚Üí ‚ÑÇ) (p : ‚Ñù‚â•0‚àû) :
      eLpNorm (fun x => ‚Äñh x‚Äñ) p Œº' = eLpNorm h p Œº' := by
    simp

  -- convolution norms.
  have h_conv_lintegral_bound :
      ‚àÄ N,
        ‚à´‚Åª x,
            (ENNReal.ofReal
              (‚à´ y, ‚Äñf (x - y)‚Äñ * ‚Äñg y‚Äñ ‚àÇ Œºpartial N)) ^ r.toReal ‚àÇ Œºpartial N
          ‚â§
        (ENNReal.ofReal
            (‚à´ y, ‚Äñg y‚Äñ *
                (eLpNorm (fun x => f (x - y)) r (Œºpartial N)).toReal ‚àÇ Œºpartial N)) ^ r.toReal := by
    intro N
    haveI : IsFiniteMeasure (Œºpartial N) := hŒºpartial_fin N
    let f_norm : G ‚Üí ‚Ñù := fun x => ‚Äñf x‚Äñ
    let g_norm : G ‚Üí ‚Ñù := fun x => ‚Äñg x‚Äñ
    have h_meas :
        AEStronglyMeasurable
          (fun q : G √ó G => f_norm (q.1 - q.2) * g_norm q.2)
          ((Œºpartial N).prod (Œºpartial N)) := by
      -- We need to show measurability of the product of norms
      simp only [f_norm, g_norm]
      -- Using the fact that norms preserve measurability and that the kernel is measurable
      have : AEStronglyMeasurable (fun q : G √ó G => ‚Äñf (q.1 - q.2) * g q.2‚Äñ)
          ((Œºpartial N).prod (Œºpartial N)) := (h_kernel_meas_piece N).norm
      -- Now we need to show that ‚Äñf(q.1 - q.2) * g(q.2)‚Äñ = ‚Äñf(q.1 - q.2)‚Äñ * ‚Äñg(q.2)‚Äñ a.e.
      convert this using 1
      ext q
      simp only [norm_mul]
    have h_prod :
        Integrable
          (fun q : G √ó G => f_norm (q.1 - q.2) * g_norm q.2)
          ((Œºpartial N).prod (Œºpartial N)) := by
      have := (h_kernel_int_piece N).norm
      simpa [f_norm, g_norm, norm_mul, mul_comm, mul_left_comm, mul_assoc] using this
    have h_int :
        ‚àÄ·µê y ‚àÇ Œºpartial N,
          Integrable (fun x => f_norm (x - y) * g_norm y) (Œºpartial N) := by
      refine (h_kernel_fiber_int_piece N).mono ?_
      intro y hy
      have hy_norm := hy.norm
      simpa [f_norm, g_norm, norm_mul, mul_comm, mul_left_comm, mul_assoc] using hy_norm
    have h_memLp :
        ‚àÄ·µê y ‚àÇ Œºpartial N,
          MemLp (fun x => f_norm (x - y) * g_norm y) r (Œºpartial N) := by
      refine (h_kernel_fiber_mem_piece N).mono ?_
      intro y hy
      have hy_norm := hy.norm
      simpa [f_norm, g_norm, norm_mul, mul_comm, mul_left_comm, mul_assoc] using hy_norm
    have h_scaling :
        ‚àÄ y : G,
          eLpNorm (fun x => f_norm (x - y) * g_norm y) r (Œºpartial N) =
            ENNReal.ofReal (g_norm y) *
              eLpNorm (fun x => f_norm (x - y)) r (Œºpartial N) := by
      intro y
      simpa [f_norm, g_norm, smul_eq_mul, mul_comm]
        using
          (eLpNorm_const_smul (Œº := Œºpartial N) (p := r)
            (c := g_norm y) (f := fun x => f_norm (x - y)))
    have h_norm :
        Integrable
          (fun y =>
            (eLpNorm (fun x => f_norm (x - y) * g_norm y) r (Œºpartial N)).toReal)
          (Œºpartial N) := by
      have h_pointwise :
          (fun y =>
              (eLpNorm (fun x => f_norm (x - y) * g_norm y) r (Œºpartial N)).toReal)
            =·µê[Œºpartial N]
          fun y =>
            ‚Äñg y‚Äñ *
              (eLpNorm (fun x => f (x - y)) r (Œºpartial N)).toReal := by
        refine Filter.Eventually.of_forall ?_
        intro y
        have h_eq := h_scaling y
        have h_toReal := congrArg ENNReal.toReal h_eq
        have hg_nonneg : 0 ‚â§ g_norm y := by exact norm_nonneg _
        have hf_eq :
            eLpNorm (fun x => f_norm (x - y)) r (Œºpartial N) =
              eLpNorm (fun x => f (x - y)) r (Œºpartial N) := by
          simp only [f_norm]
          exact eLpNorm_norm_eq_of_complex (fun x => f (x - y)) r
        simpa [f_norm, g_norm, hf_eq, ENNReal.toReal_mul, hg_nonneg]
          using h_toReal
      have h_norm' := h_norm_piece N
      exact h_norm'.congr h_pointwise.symm
    -- Apply Minkowski inequality for convolutions
    -- Note: Œºpartial N may not have IsAddRightInvariant property
    -- FIXME: Need to either prove Œºpartial N has this property or use alternative approach
    have h_minkowski :
        eLpNorm (fun x => ‚à´ y, f_norm (x - y) * g_norm y ‚àÇ(Œºpartial N)) r (Œºpartial N) ‚â§
        ENNReal.ofReal (‚à´ y, |g_norm y| * (eLpNorm (fun x =>
        f_norm (x - y)) r (Œºpartial N)).toReal ‚àÇ(Œºpartial N)) := by
      haveI : SFinite (Œºpartial N) := inferInstance
      have h_raw :
          eLpNorm
              (fun x => ‚à´ y, f_norm (x - y) * g_norm y ‚àÇ Œºpartial N) r (Œºpartial N) ‚â§
            ENNReal.ofReal
              (‚à´ y,
                  (eLpNorm (fun x => f_norm (x - y) * g_norm y) r (Œºpartial N)).toReal
                ‚àÇ Œºpartial N) := by
        refine
          minkowski_integral_inequality
            (Œº := Œºpartial N) (ŒΩ := Œºpartial N) (p := r)
            hr hr_ne_top (fun x y => f_norm (x - y) * g_norm y)
            ?_ ?_ ?_ ?_ ?_
        ¬∑ simpa using h_meas
        ¬∑ simpa using h_prod
        ¬∑ simpa using h_int
        ¬∑ simpa using h_memLp
        ¬∑ simpa using h_norm
      have h_integrand_eq :
          (fun y =>
              (eLpNorm (fun x => f_norm (x - y) * g_norm y) r (Œºpartial N)).toReal)
            =·µê[Œºpartial N]
          fun y =>
            |g_norm y| *
              (eLpNorm (fun x => f_norm (x - y)) r (Œºpartial N)).toReal := by
        refine Filter.Eventually.of_forall ?_
        intro y
        have hg_nonneg : 0 ‚â§ g_norm y := norm_nonneg _
        have hy_toReal :=
          congrArg ENNReal.toReal (h_scaling y)
        have hy_base :
            (eLpNorm (fun x => f_norm (x - y) * g_norm y) r (Œºpartial N)).toReal =
              g_norm y *
                (eLpNorm (fun x => f_norm (x - y)) r (Œºpartial N)).toReal := by
          simpa [ENNReal.toReal_mul, g_norm, hg_nonneg] using hy_toReal
        have hy_abs :
            (eLpNorm (fun x => f_norm (x - y) * g_norm y) r (Œºpartial N)).toReal =
              |g_norm y| *
                (eLpNorm (fun x => f_norm (x - y)) r (Œºpartial N)).toReal := by
          simpa [abs_of_nonneg hg_nonneg] using hy_base
        simpa using hy_abs
      have h_integral_congr :=
        integral_congr_ae h_integrand_eq
      simpa [h_integral_congr] using h_raw
    have h_eLpNorm_bound :
        eLpNorm
            (fun x => ‚à´ y, f_norm (x - y) * g_norm y ‚àÇ Œºpartial N) r (Œºpartial N)
          ‚â§
        ENNReal.ofReal
          (‚à´ y, ‚Äñg y‚Äñ *
              (eLpNorm (fun x => f (x - y)) r (Œºpartial N)).toReal ‚àÇ Œºpartial N) := by
      have h_abs :
          (fun x => ‚à´ y, f_norm (x - y) * g_norm y ‚àÇ Œºpartial N)
            = fun x => Hpartial N x := by
        funext x
        simp [Hpartial, f_norm, g_norm, mul_comm, mul_left_comm, mul_assoc]
      have h_rhs :
          (fun y => |g_norm y| * (eLpNorm (fun x => f_norm (x - y)) r (Œºpartial N)).toReal)
            =·µê[Œºpartial N]
          fun y =>
            ‚Äñg y‚Äñ *
              (eLpNorm (fun x => f (x - y)) r (Œºpartial N)).toReal := by
        refine Filter.Eventually.of_forall ?_
        intro y
        have hg_nonneg : 0 ‚â§ g_norm y := by exact norm_nonneg _
        have hf_eq :
            eLpNorm (fun x => f_norm (x - y)) r (Œºpartial N) =
              eLpNorm (fun x => f (x - y)) r (Œºpartial N) := by
          simp only [f_norm]
          exact eLpNorm_norm_eq_of_complex (fun x => f (x - y)) r
        simp [f_norm, g_norm, hf_eq, abs_of_nonneg hg_nonneg]
      have h_eq1 : ENNReal.ofReal
                  (‚à´ y,
                      |g_norm y| *
                        (eLpNorm (fun x => f_norm (x - y)) r (Œºpartial N)).toReal ‚àÇ Œºpartial N)
                =
              ENNReal.ofReal
                  (‚à´ y,
                      ‚Äñg y‚Äñ *
                        (eLpNorm (fun x => f (x - y)) r (Œºpartial N)).toReal ‚àÇ Œºpartial N) := by
            exact congrArg ENNReal.ofReal
              (integral_congr_ae h_rhs)
      have h_eq2 : (fun x => ‚à´ y, f_norm (x - y) * g_norm y ‚àÇ Œºpartial N)
                = fun x => Hpartial N x := h_abs
      -- Combine the inequalities and equalities
      calc eLpNorm (fun x => Hpartial N x) r (Œºpartial N)
        = eLpNorm (fun x => ‚à´ y, f_norm (x - y) * g_norm y ‚àÇ Œºpartial N) r (Œºpartial N) :=
          by rw [‚Üê h_eq2]
        _ ‚â§ ENNReal.ofReal (‚à´ y, |g_norm y| *
          (eLpNorm (fun x => f_norm (x - y)) r (Œºpartial N)).toReal ‚àÇ(Œºpartial N)) := h_minkowski
        _ = ENNReal.ofReal (‚à´ y, ‚Äñg y‚Äñ * (eLpNorm (fun x =>
          f (x - y)) r (Œºpartial N)).toReal ‚àÇ(Œºpartial N)) := by rw [h_eq1]
    have h_nonneg :
        ‚àÄ·µê x ‚àÇ Œºpartial N, 0 ‚â§ Hpartial N x := by
      apply (hŒºpartial_ac N).ae_le
      filter_upwards [h_integrability_all] with x hx
      -- Use that Hpartial N x is the integral of a non-negative function
      simp only [Hpartial]
      apply integral_nonneg
      intro y
      exact mul_nonneg (norm_nonneg _) (norm_nonneg _)
    -- Relate the eLpNorm to the lintegral of the r-th power
    have h_pow :
        (‚à´‚Åª x, (ENNReal.ofReal (Hpartial N x)) ^ r.toReal ‚àÇ Œºpartial N)
          =
        (eLpNorm (fun x => Hpartial N x) r (Œºpartial N)) ^ r.toReal := by
      -- Use the fact that for non-negative functions, eLpNorm^p = ‚à´‚Åª |f|^p
      have h_eq := MeasureTheory.eLpNorm_eq_lintegral_rpow_enorm
          (Œº := Œºpartial N)
          (f := fun x => Hpartial N x)
          (p := r)
          hr_ne_zero
          hr_ne_top
      -- For non-negative real functions, ‚Äñx‚Äñ‚Çë = ENNReal.ofReal x when x ‚â• 0
      have h_norm_eq : ‚àÄ·µê x ‚àÇ(Œºpartial N), ‚ÄñHpartial N x‚Äñ‚Çë = ENNReal.ofReal (Hpartial N x) := by
        filter_upwards [h_nonneg] with x hx
        simp [Real.enorm_eq_ofReal_abs, Real.norm_eq_abs, abs_of_nonneg hx]
      -- Use the rpow property to relate the expressions
      have h_integral_eq :
          (‚à´‚Åª x, ENNReal.ofReal (Hpartial N x) ^ r.toReal ‚àÇ Œºpartial N) =
            ‚à´‚Åª x, ‚ÄñHpartial N x‚Äñ‚Çë ^ r.toReal ‚àÇ Œºpartial N := by
        refine lintegral_congr_ae ?_
        filter_upwards [h_norm_eq] with x hx
        simp [hx]
      have h_pow' :
          (eLpNorm (fun x => Hpartial N x) r (Œºpartial N)) ^ r.toReal =
            ‚à´‚Åª x, ‚ÄñHpartial N x‚Äñ‚Çë ^ r.toReal ‚àÇ Œºpartial N := by
        have hrtoReal_ne_zero : r.toReal ‚â† 0 := ne_of_gt hr_toReal_pos'
        have := congrArg (fun t : ‚Ñù‚â•0‚àû => t ^ r.toReal) h_eq
        simpa [ENNReal.rpow_mul, one_div, hrtoReal_ne_zero, mul_comm, mul_left_comm, mul_assoc]
          using this
      exact h_integral_eq.trans h_pow'.symm
    -- We need to raise both sides to the r-th power
    have h_pow_bound : eLpNorm (fun x => Hpartial N x) r (Œºpartial N) ^ r.toReal ‚â§
        ENNReal.ofReal (‚à´ y, ‚Äñg y‚Äñ * (eLpNorm (fun x =>
        f (x - y)) r (Œºpartial N)).toReal ‚àÇ(Œºpartial N)) ^ r.toReal := by
      simp only [Hpartial, f_norm, g_norm] at h_eLpNorm_bound
      exact ENNReal.rpow_le_rpow h_eLpNorm_bound (ENNReal.toReal_nonneg)
    have h_final := (le_of_eq h_pow).trans h_pow_bound
    exact h_final
  -- Combine the lintegral bound with Step 4 convergence data to control
  -- the limit superior in Step 6.
  -- Notation for the key sequences appearing in Step 6.
  classical
  set Œ¶ :
      ‚Ñï ‚Üí ‚Ñù‚â•0‚àû :=
    fun N =>
      ‚à´‚Åª x, (ENNReal.ofReal (Hpartial N x)) ^ r.toReal ‚àÇ Œºpartial N
    with hŒ¶_def
  set Œ® :
      ‚Ñï ‚Üí ‚Ñù‚â•0‚àû :=
    fun N =>
      (ENNReal.ofReal
          (‚à´ y, ‚Äñg y‚Äñ *
              (eLpNorm (fun x => f (x - y)) r (Œºpartial N)).toReal ‚àÇ Œºpartial N)) ^
        r.toReal
    with hŒ®_def
  have h_limsup_control :
      (‚à´‚Åª x, (ENNReal.ofReal (H x)) ^ r.toReal ‚àÇ Œº)
        ‚â§ Filter.limsup Œ¶ Filter.atTop := by
    classical
    let f_seq : ‚Ñï ‚Üí G ‚Üí ‚Ñù‚â•0‚àû :=
      fun N x => (ENNReal.ofReal (Hpartial N x)) ^ r.toReal
    have hŒ¶_eq :
        ‚àÄ N,
          Œ¶ N =
            ‚à´‚Åª x,
              f_seq N x ‚àÇ
                (‚àë k ‚àà Finset.range (N + 1), MeasureTheory.sfiniteSeq Œº k) := by
      intro N
      simp [Œ¶, hŒ¶_def, f_seq, Œºpartial, Œºn]
    have hf_meas :
        ‚àÄ N, AEMeasurable (f_seq N) Œº := by
      intro N
      simpa [f_seq] using h_Hpartial_pow_meas N
    have hf_mono :
        ‚àÄ·µê x ‚àÇ Œº, Monotone fun N => f_seq N x := by
      simpa [f_seq] using h_Hpartial_pow_mono
    have hf_tendsto :
        ‚àÄ·µê x ‚àÇ Œº, Tendsto (fun N => f_seq N x) atTop (ùìù (g_pow x)) := by
      simpa [f_seq, g_pow] using h_Hpartial_pow_tendsto
    simpa [g_pow, f_seq] using
      (limsup_control_aux
        (Œº := Œº)
        (g_pow := g_pow)
        (Œ¶ := Œ¶)
        (f_seq := f_seq)
        (hŒ¶ := hŒ¶_eq)
        (hf_meas := hf_meas)
        (hf_mono := hf_mono)
        (hf_tendsto := hf_tendsto))
  have h_limsup_compare :
      Filter.limsup Œ¶ Filter.atTop ‚â§ Filter.limsup Œ® Filter.atTop := by
    refine Filter.limsup_le_limsup ?_
    exact
      Filter.Eventually.of_forall fun N =>
        by
          simpa [Œ¶, Œ®, hŒ¶_def, hŒ®_def]
            using h_conv_lintegral_bound N
  have h_limsup_goal :
      (‚à´‚Åª x, (ENNReal.ofReal (H x)) ^ r.toReal ‚àÇ Œº)
        ‚â§ Filter.limsup Œ® Filter.atTop :=
    le_trans h_limsup_control h_limsup_compare
  have h_limsup_rhs :
      Filter.limsup Œ® Filter.atTop ‚â§
        (eLpNorm f p Œº * eLpNorm g q Œº) ^ r.toReal := by
    classical
    refine limsup_rhs_aux Œº f g p q r hp hq hpqr hr_ne_top hf hf_r hg Œ® ?_
    intro N
    use Œºpartial N, hŒºpartial_le N, hŒºpartial_fin N
  exact le_trans h_limsup_goal h_limsup_rhs

end ConvolutionAuxiliary
