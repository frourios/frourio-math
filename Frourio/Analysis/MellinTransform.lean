import Frourio.Analysis.MellinCore
import Mathlib.MeasureTheory.Function.LpSpace.Basic
import Mathlib.MeasureTheory.Measure.Lebesgue.Basic
import Mathlib.MeasureTheory.Measure.WithDensity
import Mathlib.Analysis.SpecialFunctions.Complex.Log
import Mathlib.Analysis.Complex.Trigonometric
import Mathlib.Algebra.GroupWithZero.Basic
import Mathlib.Algebra.BigOperators.Group.Finset.Defs
import Mathlib.Tactic

open MeasureTheory Measure
open scoped ENNReal

-- Note: We deliberately avoid heavy `MeasureTheory` imports at this stage
-- to keep CI fast; the integral-based definition is recorded as a signature
-- and documented, with a lightweight placeholder for now.

namespace Frourio

-- Suppress non-critical linter suggestions to keep CI output clean for P2.
set_option linter.unnecessarySimpa false
set_option linter.unusedSimpArgs false
set_option linter.unusedTactic false
set_option linter.style.longLine false
set_option linter.unreachableTactic false

/-!
Mellin transform phase (P2): definitions and lightweight scaffolding.

This file introduces the symbols and sets needed for the Mellin-analytic
phase, without committing to heavy measure-theoretic proofs. Theorems that
require integrability or operator-norm bounds are described in comments and
will be proved in later phases once the analytic infrastructure is in place.
-/

-- no `open` to keep this file command-lean across toolchain versions
open scoped BigOperators

/-- Mellin kernel placeholder. Intended: `(x : ℂ)^(s-1)` on `x>0`.
Kept minimal in P2 to avoid adding heavy dependencies. -/
noncomputable def mellinKernel (x : ℝ) (s : ℂ) : ℂ :=
  if 0 < x then x ^ (s - 1) else 0

/--
Mellin transform (signature).

Design intent: `mellinTransform f s = ∫_{0}^{∞} f(x) x^{s-1} dx` over `ℝ`.
To keep this phase light and CI-friendly, we provide a placeholder value and
fix the interface. The integral-based definition will be introduced in P3/P4.
-/
noncomputable def mellinTransform (f : ℝ → ℂ) (s : ℂ) : ℂ :=
  ∫ t in Set.Ioi (0 : ℝ), f t * t ^ (s - 1) ∂volume

/-- Φ-difference Mellin symbol
`ϑ_Φ(Λ,s) := (Λ^{-s} - Λ^{s}) / (Λ - Λ^{-1})` (all coerced to `ℂ`). -/
noncomputable def phiSymbol (Λ : ℝ) (s : ℂ) : ℂ :=
  let a : ℂ := (Real.log Λ : ℂ)
  let num := (Complex.exp (-s * a) - Complex.exp (s * a))
  let den : ℂ := ((Λ - Λ⁻¹ : ℝ) : ℂ)
  num / den

@[simp] lemma phiSymbol_at_zero (Λ : ℝ) : phiSymbol Λ 0 = 0 := by
  -- numerator becomes 0; division yields 0 in fields
  simp [phiSymbol]

/-- Zero lattice of the Φ-symbol on the imaginary axis (for `Λ > 1`).
Formally: `{ s | ∃ k : ℤ, s = (iπ k) / log Λ }` as complex numbers. -/
def mellinZeros (Λ : ℝ) : Set ℂ :=
  { s | ∃ k : ℤ, s = (Complex.I * (Real.pi : ℂ) * (k : ℂ)) / (Real.log Λ : ℂ) }

-- Spacing of the zero lattice on the imaginary axis (design quantity).
-- Moved to MellinCore.lean

/-- Golden lattice points on the real line: `τₖ = k * (π / log φ)`. -/
noncomputable def goldenLatticePoint (φ : ℝ) (k : ℤ) : ℝ :=
  (k : ℝ) * zeroLatticeSpacing φ

/-- Predicate that `τ` lies on the golden lattice generated by `φ`:
    `∃ k ∈ ℤ, τ = k * (π / log φ)`. -/
def isGoldenLattice (φ : ℝ) (τ : ℝ) : Prop :=
  ∃ k : ℤ, τ = (k : ℝ) * zeroLatticeSpacing φ

@[simp] lemma isGoldenLattice_iff (φ : ℝ) (τ : ℝ) :
    isGoldenLattice φ τ ↔ ∃ k : ℤ, τ = (k : ℝ) * zeroLatticeSpacing φ := Iff.rfl

@[simp] lemma isGoldenLattice_zero (φ : ℝ) : isGoldenLattice φ 0 := by
  refine ⟨0, ?_⟩
  simp [isGoldenLattice, zeroLatticeSpacing]

@[simp] lemma goldenLatticePoint_spec (φ : ℝ) (k : ℤ) :
    isGoldenLattice φ (goldenLatticePoint φ k) := by
  refine ⟨k, ?_⟩
  simp [goldenLatticePoint]

/-- If `1 < Λ` then `Real.log Λ ≠ 0`. -/
lemma log_ne_zero_of_one_lt {Λ : ℝ} (h : 1 < Λ) : Real.log Λ ≠ 0 := by
  intro h0
  have hpos : 0 < Λ := lt_trans (by norm_num) h
  have : Real.exp (Real.log Λ) = Real.exp 0 := by simpa [h0]
  have : Λ = 1 := by simpa [Real.exp_log hpos, Real.exp_zero] using this
  exact (ne_of_gt h) this

-- A simpler route: show nonvanishing by contradiction via `Λ^2 ≠ 1` when `Λ>1`.
/-- If `1 < Λ` then the complex-coerced denominator is nonzero. -/
lemma denom_ne_zero_of_one_lt {Λ : ℝ} (h : 1 < Λ) : ((Λ - Λ⁻¹ : ℝ) : ℂ) ≠ 0 := by
  have hpos : 0 < Λ := lt_trans (by norm_num) h
  intro hzero
  have hzeroR : (Λ - Λ⁻¹ : ℝ) = 0 := by exact_mod_cast hzero
  have heq : Λ = Λ⁻¹ := by
    have := congrArg (fun x : ℝ => x + Λ⁻¹) hzeroR
    simpa using this
  have hmul : Λ * Λ = 1 := by
    -- multiply `Λ = Λ⁻¹` on the left by `Λ`
    have := congrArg (fun x : ℝ => Λ * x) heq
    simpa [mul_comm, mul_left_comm, mul_assoc, hpos.ne'] using this
  have hgt : 1 < Λ * Λ := lt_trans h (by simpa using (mul_lt_mul_of_pos_right h hpos))
  -- contradiction: `1 < Λ^2` but `Λ^2 = 1`
  have hlt : (1 : ℝ) < 1 := by simpa [hmul] using hgt
  exact (lt_irrefl (1 : ℝ)) hlt

/-- Completed Xiφ (Weierstrass-normalized two-point symbol):
    `Xiφ(φ,s) = (φ^{-s} − φ^{s}) / (−2 s log φ)` as a function on `ℂ`.
    Note: At `s=0` this has a removable singularity; we do not simplify it here. -/
noncomputable def Xiφ (φ : ℝ) (s : ℂ) : ℂ :=
  let a : ℂ := (Real.log φ : ℂ)
  let num := Complex.exp (-s * a) - Complex.exp (s * a)
  let den : ℂ := (-2 : ℂ) * s * a
  num / den

/-- Helper (Lemma A): for `c ≠ 0` in `ℂ`, `x / c = 0` implies `x = 0`. -/
lemma div_eq_zero_of_ne {x c : ℂ} (hc : c ≠ 0) (hx : x / c = 0) : x = 0 := by
  have hdisj : x = 0 ∨ c = 0 := by
    simpa using (div_eq_zero_iff.mp hx)
  cases hdisj with
  | inl hx0 => exact hx0
  | inr hc0 => exact (hc hc0).elim

/-- Helper (Lemma A, iff form): for `c ≠ 0` in `ℂ`, `x / c = 0 ↔ x = 0`. -/
lemma div_eq_zero_iff_of_ne {x c : ℂ} (hc : c ≠ 0) : x / c = 0 ↔ x = 0 := by
  constructor
  · exact div_eq_zero_of_ne hc
  · intro hx; simp [div_eq_mul_inv, hx]

/-- Helper (Lemma B): for `a ≠ 0` in `ℂ`, `s = r / a ↔ s * a = r`. -/
lemma eq_div_iff_mul_eq_of_ne {a s r : ℂ} (ha : a ≠ 0) : s = r / a ↔ s * a = r := by
  constructor
  · intro hs
    have h := congrArg (fun z : ℂ => z * a) hs
    -- simplify RHS to `r`
    simpa [div_eq_mul_inv, mul_comm, mul_left_comm, mul_assoc, ha]
      using h
  · intro hmul
    have h := congrArg (fun z : ℂ => z * a⁻¹) hmul
    have h1 : (s * a) * a⁻¹ = r * a⁻¹ := by simpa using h
    -- rewrite left step-by-step to isolate `s`
    have : s = r * a⁻¹ := by
      calc
        s = s * 1 := by simp
        _ = s * (a * a⁻¹) := by simp [ha]
        _ = (s * a) * a⁻¹ := by simp [mul_assoc]
        _ = r * a⁻¹ := h1
    simpa [div_eq_mul_inv] using this

/-- Helper (Lemma C): `exp (−w) = exp w` iff `exp (2w) = 1` over `ℂ`. -/
lemma exp_neg_eq_iff_exp_two_eq_one (w : ℂ) :
    Complex.exp (-w) = Complex.exp w ↔ Complex.exp (2 * w) = 1 := by
  constructor
  · intro h
    have hinv : (Complex.exp w)⁻¹ = Complex.exp w := by
      simpa [Complex.exp_neg] using h
    have hmul := congrArg (fun t => t * Complex.exp w) hinv
    have : Complex.exp (w + w) = 1 := by
      have : 1 = Complex.exp w * Complex.exp w := by
        simpa [mul_comm, mul_left_comm, mul_assoc] using hmul
      simpa [Complex.exp_add] using this.symm
    simpa [two_mul] using this
  · intro h2
    have : Complex.exp w * Complex.exp w = 1 := by
      have : Complex.exp (w + w) = 1 := by simpa [two_mul] using h2
      simpa [Complex.exp_add] using this
    have hmul := congrArg (fun t => t * (Complex.exp w)⁻¹) this
    have : Complex.exp w = (Complex.exp w)⁻¹ := by
      simpa [mul_comm, mul_left_comm, mul_assoc] using hmul
    simpa [Complex.exp_neg] using this.symm

/-- Algebraic zero-locus equivalence for `phiSymbol` under `Λ > 1`. -/
lemma phiSymbol_zero_iff {Λ : ℝ} (hΛ : 1 < Λ) (s : ℂ) :
    phiSymbol Λ s = 0 ↔ s ∈ mellinZeros Λ := by
  -- abbreviations
  set a : ℂ := (Real.log Λ : ℂ) with ha
  have hden : ((Λ - Λ⁻¹ : ℝ) : ℂ) ≠ 0 := denom_ne_zero_of_one_lt hΛ
  have ha0 : a ≠ 0 := by simpa [ha] using log_ne_zero_of_one_lt hΛ
  constructor
  · intro h0
    -- clear denominator to get numerator zero
    have hdiv : (Complex.exp (-s * a) - Complex.exp (s * a)) / ((Λ - Λ⁻¹ : ℝ) : ℂ) = 0 := by
      simpa [phiSymbol, ha] using h0
    have hnum : Complex.exp (-s * a) - Complex.exp (s * a) = 0 :=
      div_eq_zero_of_ne hden hdiv
    -- exp(-s a) = exp(s a) ⇒ exp(2 s a) = 1
    have hEq : Complex.exp (-(s * a)) = Complex.exp (s * a) := by
      simpa [neg_mul, mul_comm, mul_left_comm, mul_assoc] using (sub_eq_zero.mp hnum)
    have hexp : Complex.exp (2 * (s * a)) = 1 :=
      (exp_neg_eq_iff_exp_two_eq_one (w := s * a)).mp hEq
    -- characterize zeros via periodicity
    rcases Complex.exp_eq_one_iff.mp (by simpa [mul_comm, mul_left_comm, mul_assoc] using hexp) with ⟨k, hk⟩
    -- divide both sides by 2, then by `a`
    have hk1 := congrArg (fun z : ℂ => ((2 : ℂ)⁻¹) * z) hk
    have hE : ((2 : ℂ)⁻¹) * (2 : ℂ) = (1 : ℂ) := by
      simpa using inv_mul_cancel (by norm_num : (2 : ℂ) ≠ 0)
    have hLHS : ((2 : ℂ)⁻¹) * (2 * (s * a)) = s * a := by
      calc
        ((2 : ℂ)⁻¹) * (2 * (s * a))
            = (((2 : ℂ)⁻¹) * 2) * (s * a) := by
                simp [mul_comm, mul_left_comm, mul_assoc]
        _   = 1 * (s * a) := by simpa [hE]
        _   = s * a := by simp
    have hRHS : ((2 : ℂ)⁻¹) * ((2 : ℂ) * (Real.pi : ℂ) * Complex.I * (k : ℂ))
                  = Complex.I * (Real.pi : ℂ) * (k : ℂ) := by
      calc
        ((2 : ℂ)⁻¹) * ((2 : ℂ) * (Real.pi : ℂ) * Complex.I * (k : ℂ))
            = (((2 : ℂ)⁻¹) * (2 : ℂ)) * (Real.pi : ℂ) * Complex.I * (k : ℂ) := by
                simp [mul_comm, mul_left_comm, mul_assoc]
        _   = 1 * (Real.pi : ℂ) * Complex.I * (k : ℂ) := by simpa [hE]
        _   = (Real.pi : ℂ) * Complex.I * (k : ℂ) := by simp
        _   = Complex.I * (Real.pi : ℂ) * (k : ℂ) := by simp [mul_comm]
    have hsa : s * a = Complex.I * (Real.pi : ℂ) * (k : ℂ) := by
      -- rewrite both sides using the computed simplifications
      have := hk1
      -- LHS: ((2)⁻¹) * (2 * (s*a)) = s*a; RHS simplifies to I*π*k
      simpa [hLHS, hRHS, mul_comm, mul_left_comm, mul_assoc] using this
    -- convert to division form and finish
    refine ⟨k, ?_⟩
    have hs : s = (Complex.I * (Real.pi : ℂ) * (k : ℂ)) / a :=
      (eq_div_iff_mul_eq_of_ne ha0).mpr hsa
    simpa [mellinZeros, ha, hs]
  · intro hs
    rcases hs with ⟨k, hk⟩
    -- from lattice representation, reconstruct exp(2 s a) = 1
    have hsa : s * a = Complex.I * (Real.pi : ℂ) * (k : ℂ) :=
      (eq_div_iff_mul_eq_of_ne ha0).mp hk
    have h2 : 2 * (s * a) = (2 : ℂ) * (Real.pi : ℂ) * Complex.I * (k : ℂ) := by
      have := congrArg (fun z : ℂ => (2 : ℂ) * z) hsa
      simpa [mul_comm, mul_left_comm, mul_assoc, two_mul] using this
    -- rewrite to the orientation expected by `exp_eq_one_iff` (k on the left)
    have h2' : 2 * (s * a) = (k : ℂ) * (2 * (Real.pi : ℂ) * Complex.I) := by
      simpa [mul_comm, mul_left_comm, mul_assoc] using h2
    have hexp : Complex.exp (2 * (s * a)) = 1 := by
      simpa using Complex.exp_eq_one_iff.mpr ⟨k, h2'⟩
    -- back to numerator zero via lemma C
    have heq : Complex.exp (-(s * a)) = Complex.exp (s * a) :=
      (exp_neg_eq_iff_exp_two_eq_one (w := s * a)).mpr hexp
    have hnum : Complex.exp (-s * a) - Complex.exp (s * a) = 0 := by
      simpa [neg_mul, mul_comm, mul_left_comm, mul_assoc] using (sub_eq_zero.mpr heq)
    -- fold back into phiSymbol definition
    have : phiSymbol Λ s = 0 := by
      -- avoid `div_eq_zero_iff` by rewriting division as multiplication
      change (Complex.exp (-s * a) - Complex.exp (s * a)) / ((Λ - Λ⁻¹ : ℝ) : ℂ) = 0
      rw [hnum]
      simp [div_eq_mul_inv]
    exact this

/-- Zero-locus equivalence for `Xiφ` away from the removable singularity at `s=0`.
    For `1 < φ` and `s ≠ 0`, `Xiφ φ s = 0` iff `s` lies on the imaginary lattice
    `{ i π k / log φ | k ∈ ℤ }`. -/
lemma Xiφ_zero_iff {φ : ℝ} (hφ : 1 < φ) {s : ℂ} (hs : s ≠ 0) :
    Xiφ φ s = 0 ↔ s ∈ mellinZeros φ := by
  -- Abbreviations
  set a : ℂ := (Real.log φ : ℂ) with ha
  have ha0 : a ≠ 0 := by simpa [ha] using log_ne_zero_of_one_lt hφ
  -- Denominator `(-2) * s * a` is nonzero under the assumptions
  have hden : ((-2 : ℂ) * s * a) ≠ 0 := by
    have h2 : (-2 : ℂ) ≠ 0 := by norm_num
    exact mul_ne_zero (mul_ne_zero h2 hs) ha0
  constructor
  · intro h0
    have hdiv : (Complex.exp (-s * a) - Complex.exp (s * a)) / ((-2 : ℂ) * s * a) = 0 := by
      simpa [Xiφ, ha] using h0
    have hnum : Complex.exp (-s * a) - Complex.exp (s * a) = 0 :=
      (div_eq_zero_iff_of_ne (x := (Complex.exp (-s * a) - Complex.exp (s * a))) (c := (-2 : ℂ) * s * a) hden).1 hdiv
    have hEq : Complex.exp (-(s * a)) = Complex.exp (s * a) := by
      simpa [neg_mul, mul_comm, mul_left_comm, mul_assoc] using (sub_eq_zero.mp hnum)
    have hexp : Complex.exp (2 * (s * a)) = 1 :=
      (exp_neg_eq_iff_exp_two_eq_one (w := s * a)).mp hEq
    rcases Complex.exp_eq_one_iff.mp (by simpa [mul_comm, mul_left_comm, mul_assoc] using hexp) with ⟨k, hk⟩
    have hs' : s = (Complex.I * (Real.pi : ℂ) * (k : ℂ)) / a := by
      -- From `2 s a = 2 π i k`, divide by `2` and then by `a`.
      have h2 : 2 * (s * a) = (k : ℂ) * (2 * (Real.pi : ℂ) * Complex.I) := by
        simpa [mul_comm, mul_left_comm, mul_assoc, two_mul] using hk
      -- multiply both sides by ((2)⁻¹) on the right to cancel 2
      have h2' := congrArg (fun z : ℂ => ((2 : ℂ)⁻¹) * z) h2
      have hL : ((2 : ℂ)⁻¹) * (2 * (s * a)) = s * a := by
        have : ((2 : ℂ)⁻¹) * (2 : ℂ) = (1 : ℂ) := by
          simpa using inv_mul_cancel (by norm_num : (2 : ℂ) ≠ 0)
        simpa [mul_comm, mul_left_comm, mul_assoc, this] using h2'
      have hR : ((2 : ℂ)⁻¹) * ((k : ℂ) * (2 * (Real.pi : ℂ) * Complex.I))
                  = (k : ℂ) * (Real.pi : ℂ) * Complex.I := by
        simp [mul_comm, mul_left_comm, mul_assoc]
      -- Now divide by `a`
      have hsa : s * a = (k : ℂ) * (Real.pi : ℂ) * Complex.I := by
        simpa [hL, hR, mul_comm, mul_left_comm, mul_assoc] using h2'
      exact (eq_div_iff_mul_eq_of_ne ha0).mpr (by simpa [mul_comm, mul_left_comm, mul_assoc] using hsa)
    -- Package as membership in the lattice set with the same k
    refine ⟨k, ?_⟩
    -- Rewrite denominator `a` to `Real.log φ` via `ha`
    have : s = (Complex.I * (Real.pi : ℂ) * (k : ℂ)) / (Real.log φ : ℂ) := by
      simpa [ha] using hs'
    -- Convert equality to the set membership statement form
    simpa [mellinZeros, this]
  · intro hs_mem
    rcases hs_mem with ⟨k, hk⟩
    have hsa : s * a = Complex.I * (Real.pi : ℂ) * (k : ℂ) :=
      (eq_div_iff_mul_eq_of_ne ha0).mp hk
    have h2 : 2 * (s * a) = (2 : ℂ) * (Real.pi : ℂ) * Complex.I * (k : ℂ) := by
      have := congrArg (fun z : ℂ => (2 : ℂ) * z) hsa
      simpa [mul_comm, mul_left_comm, mul_assoc, two_mul] using this
    have h2' : 2 * (s * a) = (k : ℂ) * (2 * (Real.pi : ℂ) * Complex.I) := by
      simpa [mul_comm, mul_left_comm, mul_assoc] using h2
    have hexp : Complex.exp (2 * (s * a)) = 1 := by
      simpa using Complex.exp_eq_one_iff.mpr ⟨k, h2'⟩
    have heq : Complex.exp (-(s * a)) = Complex.exp (s * a) :=
      (exp_neg_eq_iff_exp_two_eq_one (w := s * a)).mpr hexp
    have hnum : Complex.exp (-s * a) - Complex.exp (s * a) = 0 := by
      simpa [neg_mul, mul_comm, mul_left_comm, mul_assoc] using (sub_eq_zero.mpr heq)
    -- conclude Xiφ = 0 by proving the fractional form equals 0 directly,
    -- then rewriting back to `Xiφ` to avoid spurious case splits
    have hfrac :
        (Complex.exp (-s * a) - Complex.exp (s * a)) / ((-2 : ℂ) * s * a) = 0 := by
      rw [hnum, zero_div]
    simpa [Xiφ, ha] using hfrac

-- (Algebraic zero-locus equivalence for `phiSymbol` under `Λ > 1` will be added
-- in a subsequent step, leveraging `Complex.exp_eq_one_iff`. We keep helpers
-- above and leave this as design intent to preserve AC5.)

/-- Vertical line `Re s = σ` as a subtype. -/
def VerticalLine (σ : ℝ) := { s : ℂ // s.re = σ }

-- Multiplicative Haar measure on (0,∞)
-- Moved to MellinCore.lean

-- Hilbert-Sobolev space Hσ
-- Moved to MellinCore.lean

-- Coercion to function
-- Moved to MellinCore.lean

/-- Action `Tφ` on `Hσ`.

The long-term definition multiplies the Mellin-side profile of `u` by the
symbol `phiSymbol (Λ, σ + iτ)` and then pulls the result back to the weighted
L² side.  Executing this construction requires the Mellin–Plancherel isometry,
which is still work-in-progress.  Until that machinery is available we keep a
concrete placeholder that simply returns the zero element of `Hσ (σ - 1)`.
This lets downstream code compile while making the future intent explicit. -/
noncomputable def Tphi (_Λ : ℝ) (σ : ℝ) : Hσ σ → Hσ (σ - 1) :=
  fun _u => 0

/-- The norm on `H_σ` induced from the L² structure with weighted measure.
This is the standard L² norm with respect to the measure x^(2σ-1) dx/x on (0,∞). -/
noncomputable def HσNorm (σ : ℝ) (u : Hσ σ) : ℝ := ‖u‖

/-- Norm identity (skeleton): `Tphi` acts isometrically between the placeholder
spaces `H_σ → H_{σ-1}`. This records the intended isometry at the statement level.
It will be replaced by a true equality after introducing the Mellin–Plancherel
norm in later phases. -/
theorem Tphi_norm_identity (Λ σ : ℝ) (u : Hσ σ) :
  HσNorm (σ - 1) (Tphi Λ σ u) = HσNorm σ u := by
  -- Currently Tphi returns 0, so the left side is ‖0‖ = 0
  -- This is a placeholder until Tphi is properly implemented
  simp [HσNorm, Tphi]
  sorry -- Will be proven once Tphi is implemented as isometry

/-- Candidate operator-norm bound expression (design quantity). -/
noncomputable def phiSymbolBound (Λ σ : ℝ) : ℝ :=
  2 * Real.cosh (σ * Real.log Λ) / (Λ - Λ⁻¹)

/-- Helper: division by `x` for `ℝ → ℂ` functions. -/
noncomputable def divByX (g : ℝ → ℂ) : ℝ → ℂ := fun x => g x / (x : ℂ)

/-- Placeholder for the operator norm of `Tphi Λ` acting `H_σ → H_{σ-1}`.
We keep it as a design quantity referencing the operator one would get
by Mellin-side multiplication with `phiSymbol`. -/
noncomputable def opNorm_Tphi (_Λ : ℝ) (_σ : ℝ) : ℝ := 0

/-- Operator-norm bound statement for `Tphi` along the vertical line `Re s = σ`.
Design intent: for `Λ > 1`, `‖T_{Φ,Λ}‖ ≤ phiSymbolBound Λ σ`.
Recorded as a `Prop` inequality between a placeholder norm and the explicit RHS. -/
def op_norm_bound (Λ σ : ℝ) : Prop :=
  1 < Λ → opNorm_Tphi Λ σ ≤ phiSymbolBound Λ σ

/-- Φ-difference operator on the physical side (placeholder). -/
noncomputable def mellinPhiDiff (_Λ : ℝ) (f : ℝ → ℂ) : ℝ → ℂ := fun x => f x

/--
Concrete m-point Mellin-difference symbol `phi_m` as a finite linear
combination of the two-point symbol `phiSymbol` with phase weights. The
weights use m-th roots of unity `exp(2π i j / m)` and unit shifts in `s`.
For `m = 0`, we set `phi_m` to `0` by convention.
-/
noncomputable def SmSymbol (m : ℕ) (Λ : ℝ) (s : ℂ) : ℂ :=
  if _h : m = 0 then 0 else
    ∑ j : Fin m,
      let w : ℂ := Complex.exp (Complex.I * (2 * Real.pi) * ((j.1 : ℝ) / (m : ℝ)))
      w * phiSymbol Λ (s + (j.1 : ℂ))

@[simp] lemma SmSymbol_zero_m (Λ : ℝ) (s : ℂ) : SmSymbol 0 Λ s = 0 := by
  simp [SmSymbol]

-- (Replaced below by the concrete `phi_m` and an alias `SmSymbol`.)

/-- Design zero set for `S_m` (placeholder). In later phases this will
be the corresponding arithmetic lattice generalizing `mellinZeros` for `m=2`. -/
def SmZeros (_m : ℕ) (_Λ : ℝ) : Set ℂ := { _s | False }

/-- Statement (as a `Prop`) that the zero-locus of `S_m` is described by `SmZeros`.
No proof is provided at this phase. -/
def Sm_zero_locus (m : ℕ) (Λ : ℝ) : Prop :=
  ∀ s : ℂ, SmSymbol m Λ s = 0 ↔ s ∈ SmZeros m Λ

/-- Bohr almost periodicity predicate on `ℝ → ℂ` (minimalist version).
We use a classical ε–T formulation of relatively dense ε-almost periods. -/
def IsBohrAlmostPeriodic (F : ℝ → ℂ) : Prop :=
  ∀ ε > 0, ∀ T > 0, ∃ τ : ℝ, |τ| ≤ T ∧ ∀ t : ℝ, ‖F (t + τ) - F t‖ < ε

/-- Statement (as a `Prop`) that the vertical-line trace of `S_m` is
Bohr almost periodic. This captures the intended regularity in the design
without committing to the full harmonic-analytic development at this stage. -/
def Sm_bohr_almost_periodic (m : ℕ) (Λ σ : ℝ) : Prop :=
  IsBohrAlmostPeriodic (fun t : ℝ => SmSymbol m Λ (σ + Complex.I * (t : ℂ)))

/-!
Zero-locus equivalence for `phiSymbol` (Λ > 1)
We provide a constructive proof via the periodicity of `Complex.exp`.
-/

-- (Algebraic zero-locus equivalence for `phiSymbol` under `Λ > 1`:
--   phiSymbol Λ s = 0 ↔ s ∈ mellinZeros Λ
-- will be added after introducing a few tiny helper lemmas for
-- `div_eq_zero` and `eq_div_iff_mul_eq` style rewrites to keep the proof
-- compact and robust on this toolchain.)

end Frourio
