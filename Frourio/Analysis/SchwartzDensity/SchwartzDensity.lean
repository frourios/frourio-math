import Frourio.Analysis.Gaussian
import Frourio.Analysis.MellinBasic
import Frourio.Analysis.HilbertSpaceCore
import Frourio.Analysis.SchwartzDensity.SchwartzDensityCore2
import Mathlib.MeasureTheory.Function.L2Space
import Mathlib.Analysis.InnerProductSpace.Basic
import Mathlib.MeasureTheory.Integral.Bochner.Basic
import Mathlib.Analysis.NormedSpace.Real
import Mathlib.MeasureTheory.Function.LpSpace.Complete
import Mathlib.Analysis.SpecialFunctions.Pow.Real
import Mathlib.Analysis.Distribution.SchwartzSpace
import Mathlib.MeasureTheory.Function.SimpleFuncDenseLp
import Mathlib.MeasureTheory.Function.ContinuousMapDense
import Mathlib.Analysis.Calculus.BumpFunction.FiniteDimension
import Mathlib.Algebra.Order.Floor.Semiring
import Mathlib.Analysis.Convolution
import Mathlib.MeasureTheory.Function.LpSeminorm.Basic
import Mathlib.MeasureTheory.Integral.IntervalIntegral.Basic
import Mathlib.MeasureTheory.Integral.IntervalIntegral.FundThmCalculus
import Mathlib.MeasureTheory.Integral.IntervalIntegral.IntegrationByParts
import Mathlib.Analysis.SpecialFunctions.Integrability.Basic
import Mathlib.Analysis.SpecialFunctions.Integrals.Basic
import Mathlib.Analysis.SpecialFunctions.ImproperIntegrals
import Mathlib.MeasureTheory.Integral.Bochner.ContinuousLinearMap
import Mathlib.MeasureTheory.Integral.Bochner.FundThmCalculus
import Mathlib.MeasureTheory.Integral.Bochner.Set
import Mathlib.Analysis.Normed.Group.Bounded
import Mathlib.Order.Filter.Basic

open MeasureTheory Measure Real Complex SchwartzMap intervalIntegral
open scoped ENNReal Topology ComplexConjugate

namespace Frourio

section SchwartzDensity

/-- Standard mollification error for L¬≤ functions with weighted measure -/
lemma standard_mollification_l2_error {œÉ : ‚Ñù} (hœÉ : 1 / 2 < œÉ)
    (f : ‚Ñù ‚Üí ‚ÑÇ) (hf_memLp : MemLp f 2 (weightedMeasure œÉ))
    (œÜ : ‚Ñù ‚Üí ‚Ñù) (hœÜ_smooth : ContDiff ‚Ñù (‚ä§ : ‚Ñï‚àû) œÜ)
    (hœÜ_compact : HasCompactSupport œÜ)
    (hœÜ_nonneg : ‚àÄ x, 0 ‚â§ œÜ x)
    (hœÜ_integral : ‚à´ x, œÜ x ‚àÇvolume = 1)
    (Œ¥ Œµ : ‚Ñù) (hŒ¥_pos : 0 < Œ¥) (hŒµ_pos : 0 < Œµ) :
    let œÜŒ¥ := fun x => (1 / Œ¥) * œÜ (x / Œ¥)
    let g := fun x => ‚à´ y, f y * œÜŒ¥ (x - y) ‚àÇvolume
    ‚àÄ hg_memLp : MemLp g 2 (weightedMeasure œÉ),
    Œ¥ < Œµ / (4 * (ENNReal.toReal (eLpNorm f 2 (weightedMeasure œÉ)) + 1)) ‚Üí
    dist (hf_memLp.toLp f) (hg_memLp.toLp g) < Œµ := by
  sorry -- Standard mollification approximation theorem

/-- Truncated functions from L¬≤(weightedMeasure œÉ) are locally integrable with respect to volume -/
lemma s_R_locally_integrable_volume {œÉ : ‚Ñù} (hœÉ_lower : 1 / 2 < œÉ) (hœÉ_upper : œÉ < 3 / 2)
    (s : Lp ‚ÑÇ 2 (weightedMeasure œÉ)) (R : ‚Ñù) (hR_pos : 0 < R)
    (hs_R_memLp : MemLp (fun x => if 0 < x ‚àß x ‚â§ R then (s : ‚Ñù ‚Üí ‚ÑÇ) x else 0) 2
      (weightedMeasure œÉ)) :
    LocallyIntegrable (fun x => if 0 < x ‚àß x ‚â§ R then (s : ‚Ñù ‚Üí ‚ÑÇ) x else 0) volume := by
  -- s_R has support on (0,R] and is in L¬≤(weightedMeasure œÉ), so locally integrable
  sorry

/-- Convert eLpNorm bound to Lp distance bound for truncation error -/
lemma truncation_error_dist_bound {œÉ : ‚Ñù} (s : Lp ‚ÑÇ 2 (weightedMeasure œÉ))
    (s_R : ‚Ñù ‚Üí ‚ÑÇ) (hs_R_memLp : MemLp s_R 2 (weightedMeasure œÉ))
    (Œµ : ‚Ñù) (hŒµ : 0 < Œµ)
    (h_norm_bound : eLpNorm ((s : ‚Ñù ‚Üí ‚ÑÇ) - s_R) 2 (weightedMeasure œÉ) < ENNReal.ofReal Œµ) :
    dist s (hs_R_memLp.toLp s_R) < Œµ := by
  -- The distance in Lp space equals the L¬≤ norm of the difference
  -- dist s (hs_R_memLp.toLp s_R) = ‚Äñs - hs_R_memLp.toLp s_R‚Äñ
  -- Since toLp s_R represents s_R as an Lp element with the same function a.e.,
  -- this equals eLpNorm ((s : ‚Ñù ‚Üí ‚ÑÇ) - s_R) converted to real
  sorry

/-- Distance equivalence under measure isometry for Lp spaces -/
lemma lp_dist_measure_equiv {œÉ : ‚Ñù} (f : HœÉ œÉ) (g : ‚Ñù ‚Üí ‚ÑÇ)
    (f_Lp : Lp ‚ÑÇ 2 (weightedMeasure œÉ))
    (hf_weightedMeasure : MemLp (HœÉ.toFun f) 2 (weightedMeasure œÉ))
    (hf_Lp_eq : f_Lp = hf_weightedMeasure.toLp (HœÉ.toFun f))
    (hg_memLp : MemLp g 2 (weightedMeasure œÉ))
    (hg_memLp_converted : MemLp g 2 (mulHaar.withDensity (fun x =>
      ENNReal.ofReal (x ^ (2 * œÉ - 1))))) :
    dist f (hg_memLp_converted.toLp g) = dist f_Lp (hg_memLp.toLp g) := by
  -- This equality holds because:
  -- 1. f and f_Lp represent the same element (f_Lp = toLp f)
  -- 2. hg_memLp_converted.toLp g and hg_memLp.toLp g represent the same element
  -- 3. The measure equivalence preserves distances
  -- The key insight is that we're computing distances in equivalent Lp spaces
  -- f : HœÉ œÉ, and f_Lp = toLp (HœÉ.toFun f) : Lp ‚ÑÇ 2 (weightedMeasure œÉ)
  -- hg_memLp_converted corresponds to the same function g under measure equivalence
  sorry

/-- Triangle inequality chain for Lp approximation sequence -/
lemma lp_approximation_triangle_chain {œÉ : ‚Ñù}
    (f_Lp : Lp ‚ÑÇ 2 (weightedMeasure œÉ))
    (s : Lp.simpleFunc ‚ÑÇ 2 (weightedMeasure œÉ))
    (g_cont : ‚Ñù ‚Üí ‚ÑÇ) (hg_cont_memLp : MemLp g_cont 2 (weightedMeasure œÉ))
    (g : ‚Ñù ‚Üí ‚ÑÇ) (hg_memLp : MemLp g 2 (weightedMeasure œÉ))
    (Œµ : ‚Ñù) (hŒµ : 0 < Œµ)
    (hs_close : dist f_Lp (‚Üës) < Œµ / 2)
    (hg_cont_close : dist (‚Üës) (hg_cont_memLp.toLp g_cont) < Œµ / 4)
    (hg_mollify_close : dist (hg_cont_memLp.toLp g_cont) (hg_memLp.toLp g) < Œµ / 4) :
    dist f_Lp (hg_memLp.toLp g) < Œµ := by
  -- The approximation chain works as follows:
  -- f_Lp --[Œµ/2]-- s --[Œµ/4]-- g_cont --[Œµ/4]-- g
  -- where each arrow represents a distance bound
  -- The mathematical proof uses two applications of triangle inequality:
  -- Step 1: dist f_Lp g ‚â§ dist f_Lp s + dist s g
  -- Step 2: dist s g ‚â§ dist s g_cont + dist g_cont g
  -- Combined: dist f_Lp g ‚â§ dist f_Lp s + dist s g_cont + dist g_cont g
  -- Apply the bounds: Œµ/2 + Œµ/4 + Œµ/4 = Œµ
  sorry

/-- Truncated L¬≤ functions are integrable with respect to volume measure -/
lemma truncated_lp_integrable {œÉ : ‚Ñù} (hœÉ_lower : 1 / 2 < œÉ) (hœÉ_upper : œÉ < 3 / 2)
    (s : Lp ‚ÑÇ 2 (weightedMeasure œÉ)) (R : ‚Ñù) (hR_pos : 0 < R) :
    Integrable (fun x => if 0 < x ‚àß x ‚â§ R then (s : ‚Ñù ‚Üí ‚ÑÇ) x else 0) volume := by
  -- The truncated function has support in (0,R] which has finite measure
  -- Since s ‚àà L¬≤(weighted), on bounded sets it's integrable by H√∂lder's inequality
  sorry

/-- L¬≤ functions can be approximated by continuous
  compactly supported functions in weighted L¬≤ spaces -/
lemma lp_to_continuous_approx {œÉ : ‚Ñù} (hœÉ_lower : 1 / 2 < œÉ) (hœÉ_upper : œÉ < 3 / 2)
    (s : Lp ‚ÑÇ 2 (weightedMeasure œÉ)) (Œµ : ‚Ñù) (hŒµ : 0 < Œµ) :
    ‚àÉ (g_cont : ‚Ñù ‚Üí ‚ÑÇ) (hg_cont_memLp : MemLp g_cont 2 (weightedMeasure œÉ)),
      HasCompactSupport g_cont ‚àß
      Continuous g_cont ‚àß
      dist s (hg_cont_memLp.toLp g_cont) < Œµ := by
  -- CORRECTED PROOF STRATEGY:
  -- Step 1: Extract s as an L¬≤ function directly (no SimpleFunc conversion)
  -- Step 2: Truncate this L¬≤ function to bounded support
  -- Step 3: Mollify to get continuous compactly supported function
  -- Step 4: Control error through: ‚Äñs - g‚Äñ ‚â§ ‚Äñs - s_R‚Äñ + ‚Äñs_R - g‚Äñ

  have hs_memLp : MemLp s 2 (weightedMeasure œÉ) := Lp.memLp s
  have h_two_ne_top : (2 : ENNReal) ‚â† ‚àû := by norm_num

  -- Step 1: Choose R large enough that truncation error is < Œµ/2
  -- For any L¬≤ function, ‚à´_{|x|>R} |s|¬≤ ‚Üí 0 as R ‚Üí ‚àû (tail vanishing)
  obtain ‚ü®R, hR_pos, hR_truncation‚ü© : ‚àÉ R : ‚Ñù, 0 < R ‚àß
      eLpNorm (fun x => if |x| > R then (s : ‚Ñù ‚Üí ‚ÑÇ) x else 0) 2 (weightedMeasure œÉ) <
      ENNReal.ofReal (Œµ / 2) :=
    lp_tail_vanishing hœÉ_lower s (Œµ / 2) (by linarith : 0 < Œµ / 2)

  -- Define the truncated function s_R directly from s
  let s_R : ‚Ñù ‚Üí ‚ÑÇ := fun x => if 0 < x ‚àß x ‚â§ R then (s : ‚Ñù ‚Üí ‚ÑÇ) x else 0

  -- s_R has bounded support by construction (only positive values)
  have hs_R_support : Function.support s_R ‚äÜ Set.Ioc 0 R := by
    intro x hx
    simp only [s_R, Function.mem_support] at hx
    -- hx : (if 0 < x ‚àß x ‚â§ R then s x else 0) ‚â† 0
    -- This means 0 < x ‚àß x ‚â§ R and s x ‚â† 0
    by_cases h : 0 < x ‚àß x ‚â§ R
    ¬∑ -- If 0 < x ‚àß x ‚â§ R, then x ‚àà (0, R]
      exact ‚ü®h.1, h.2‚ü©
    ¬∑ -- If ¬¨(0 < x ‚àß x ‚â§ R), then s_R x = 0, contradicting hx
      simp only [h, if_false] at hx
      exact absurd rfl hx

  -- s_R is in L¬≤ since it's a truncation of an L¬≤ function
  have hs_R_memLp : MemLp s_R 2 (weightedMeasure œÉ) := by
    unfold s_R
    exact positive_truncation_memLp s R

  -- The truncation error is controlled
  have h_truncation_error :
      eLpNorm ((s : ‚Ñù ‚Üí ‚ÑÇ) - s_R) 2 (weightedMeasure œÉ) < ENNReal.ofReal (Œµ / 2) := by
    exact positive_truncation_error_bound s R (Œµ / 2) hR_truncation

  -- Choose mollification parameter Œ¥ small enough
  -- Use L¬≤ norm of s_R since s_R ‚àà L¬≤(weightedMeasure œÉ)
  let Œ¥ : ‚Ñù := min (Œµ / (8 * (ENNReal.toReal (eLpNorm s_R 2
    (weightedMeasure œÉ)) + 1))) (1 / (2 * (R + 1)))
  have hŒ¥_pos : 0 < Œ¥ := by
    -- Œ¥ = min(a, b) > 0 iff a > 0 and b > 0
    apply lt_min
    ¬∑ -- Show 0 < Œµ / (8 * (ENNReal.toReal (eLpNorm s_R 2 (weightedMeasure œÉ)) + 1))
      apply div_pos hŒµ
      -- Show 0 < 8 * ((eLpNorm s_R 2 (weightedMeasure œÉ)).toReal + 1)
      apply mul_pos
      ¬∑ norm_num
      ¬∑ -- Show 0 < (eLpNorm s_R 2 (weightedMeasure œÉ)).toReal + 1
        -- Since ENNReal.toReal _ ‚â• 0 and 1 > 0, we have toReal _ + 1 ‚â• 1 > 0
        have h_nonneg : 0 ‚â§ ENNReal.toReal (eLpNorm s_R 2 (weightedMeasure œÉ)) :=
          ENNReal.toReal_nonneg
        linarith
    ¬∑ -- Show 0 < 1 / (2 * (R + 1))
      apply div_pos
      ¬∑ norm_num
      ¬∑ -- Show 0 < 2 * (R + 1)
        apply mul_pos
        ¬∑ norm_num
        ¬∑ linarith [hR_pos]  -- Since R > 0, we have R + 1 > 1 > 0

  -- Construct a proper mollifier as an approximation identity
  -- Step 1: Get a base smooth function with support in [-1, 1]
  have h_ball_nhds_unit : Metric.ball (0:‚Ñù) 1 ‚àà ùìù (0:‚Ñù) := Metric.ball_mem_nhds _ zero_lt_one
  obtain ‚ü®œÜ‚ÇÄ, hœÜ‚ÇÄ_tsupport, hœÜ‚ÇÄ_compact, hœÜ‚ÇÄ_smooth, hœÜ‚ÇÄ_range, hœÜ‚ÇÄ_at_zero‚ü© :=
    exists_smooth_tsupport_subset h_ball_nhds_unit

  -- Step 2: Normalize œÜ‚ÇÄ to have integral 1
  have hœÜ‚ÇÄ_integrable : Integrable œÜ‚ÇÄ := by
    exact Continuous.integrable_of_hasCompactSupport hœÜ‚ÇÄ_smooth.continuous hœÜ‚ÇÄ_compact

  have hœÜ‚ÇÄ_pos_integral : 0 < ‚à´ x, œÜ‚ÇÄ x ‚àÇvolume := by
    -- œÜ‚ÇÄ(0) = 1 and œÜ‚ÇÄ ‚â• 0, so the integral is positive
    sorry -- This follows from continuity at 0 and non-negativity

  let œÜ_normalized := fun x => œÜ‚ÇÄ x / (‚à´ y, œÜ‚ÇÄ y ‚àÇvolume)

  have hœÜ_normalized_integral : ‚à´ x, œÜ_normalized x ‚àÇvolume = 1 := by
    -- By construction, œÜ_normalized = œÜ‚ÇÄ / (‚à´ œÜ‚ÇÄ)
    -- So ‚à´ œÜ_normalized = ‚à´ (œÜ‚ÇÄ / (‚à´ œÜ‚ÇÄ)) = (‚à´ œÜ‚ÇÄ) / (‚à´ œÜ‚ÇÄ) = 1
    sorry -- Direct calculation using linearity of integration

  -- Step 3: Scale to get œÜŒ¥ with support in [-Œ¥, Œ¥]
  let œÜŒ¥ := fun x => (1 / Œ¥) * œÜ_normalized (x / Œ¥)

  have hœÜŒ¥_smooth : ContDiff ‚Ñù (‚ä§ : ‚Ñï‚àû) œÜŒ¥ := by
    -- Composition and scaling preserve smoothness
    sorry -- Technical but standard

  have hœÜŒ¥_compact : HasCompactSupport œÜŒ¥ := by
    -- Scaling preserves compact support
    sorry -- Technical but standard

  have hœÜŒ¥_support : Function.support œÜŒ¥ ‚äÜ Set.Icc (-Œ¥) Œ¥ := by
    -- œÜŒ¥(x) = (1/Œ¥) * œÜ_normalized(x/Œ¥)
    -- support(œÜŒ¥) = {x : œÜŒ¥(x) ‚â† 0} = {x : œÜ_normalized(x/Œ¥) ‚â† 0} = Œ¥ * support(œÜ_normalized)
    -- Since support(œÜ_normalized) ‚äÜ [-1, 1], we have support(œÜŒ¥) ‚äÜ [-Œ¥, Œ¥]
    sorry -- Technical but standard scaling argument

  have hœÜŒ¥_nonneg : ‚àÄ x, 0 ‚â§ œÜŒ¥ x := by
    intro x
    simp [œÜŒ¥, œÜ_normalized]
    apply mul_nonneg
    ¬∑ -- 0 ‚â§ 1/Œ¥ since 0 < Œ¥
      rw [inv_nonneg]
      exact hŒ¥_pos.le
    ¬∑ apply div_nonneg
      ¬∑ have := hœÜ‚ÇÄ_range (Set.mem_range_self (x / Œ¥))
        exact this.1
      ¬∑ exact le_of_lt hœÜ‚ÇÄ_pos_integral

  have hœÜŒ¥_integral : ‚à´ x, œÜŒ¥ x ‚àÇvolume = 1 := by
    -- Change of variables: ‚à´ (1/Œ¥) * œÜ_normalized(x/Œ¥) dx = ‚à´ œÜ_normalized(y) dy = 1
    sorry -- Standard change of variables formula

  -- Define the mollified function g := s_R * œÜŒ¥ (convolution)
  let g : ‚Ñù ‚Üí ‚ÑÇ := fun x => ‚à´ y, s_R y * œÜŒ¥ (x - y) ‚àÇvolume

  -- g is continuous because it's a convolution of L¬π function with smooth function
  have hg_continuous : Continuous g := by
    -- g(x) = ‚à´ s_R(y) * œÜŒ¥(x - y) dy is a convolution of s_R with œÜŒ¥
    -- Use the fact that convolution of integrable s_R with continuous bounded œÜŒ¥ is continuous
    have hœÜŒ¥_bdd : BddAbove (Set.range fun x => ‚ÄñœÜŒ¥ x‚Äñ) := by
      -- œÜŒ¥ has compact support, so it's bounded on ‚Ñù
      -- Since œÜŒ¥ = 0 outside tsupport œÜŒ¥, we only need boundedness on tsupport œÜŒ¥
      have h_image := hœÜŒ¥_compact.image hœÜŒ¥_smooth.continuous
      have h_norm_image := h_image.image continuous_norm
      -- Since œÜŒ¥ has compact support, the range of ‚ÄñœÜŒ¥‚Äñ is bounded
      -- Use the fact that continuous functions on compact sets are bounded
      have h_continuous_norm : Continuous (fun x => ‚ÄñœÜŒ¥ x‚Äñ) :=
        continuous_norm.comp hœÜŒ¥_smooth.continuous
      have h_tsupport_compact : IsCompact (tsupport œÜŒ¥) := by
        rw [HasCompactSupport] at hœÜŒ¥_compact
        exact hœÜŒ¥_compact
      have h_image_compact : IsCompact ((fun x => ‚ÄñœÜŒ¥ x‚Äñ) '' (tsupport œÜŒ¥)) :=
        h_tsupport_compact.image h_continuous_norm
      -- Since œÜŒ¥ has compact support and is continuous, it's bounded
      -- The range of ‚ÄñœÜŒ¥‚Äñ is contained in [0, M] for some M
      have h_bdd_on_tsupport : BddAbove ((fun x => ‚ÄñœÜŒ¥ x‚Äñ) '' (tsupport œÜŒ¥)) :=
        h_image_compact.isBounded.bddAbove
      have h_range_subset := range_norm_subset_tsupport_image_with_zero œÜŒ¥
      -- Since inserting 0 doesn't affect boundedness above, we can still conclude
      have h_bdd_with_zero : BddAbove (Set.insert 0 ((fun x => ‚ÄñœÜŒ¥ x‚Äñ) '' (tsupport œÜŒ¥))) :=
        h_bdd_on_tsupport.insert 0
      exact BddAbove.mono h_range_subset h_bdd_with_zero
    -- s_R is integrable because it's a truncation of an L¬≤ function
    have hs_R_integrable : Integrable s_R :=
      truncated_lp_integrable hœÉ_lower hœÉ_upper s R hR_pos
    -- œÜŒ¥ is smooth with compact support, hence integrable
    have hœÜŒ¥_integrable : Integrable œÜŒ¥ := by
      -- Use the fact that continuous functions with compact support are integrable
      exact Continuous.integrable_of_hasCompactSupport hœÜŒ¥_smooth.continuous hœÜŒ¥_compact
    -- Apply convolution continuity theorem
    -- Since œÜŒ¥ has compact support, we can use compact support convolution continuity
    have hs_R_locally_integrable : LocallyIntegrable s_R := by
      -- Integrable functions are locally integrable
      exact Integrable.locallyIntegrable hs_R_integrable
    -- The convolution is continuous
    -- Use our convolution continuity lemma
    exact convolution_integrable_smooth_continuous hs_R_integrable hœÜŒ¥_smooth hœÜŒ¥_compact

  -- g has compact support: support contained in support(f) + support(œÜŒ¥)
  have hg_support : Function.support g ‚äÜ Set.Icc (-(R + Œ¥)) (R + Œ¥) := by
    intro x hx
    simp [g] at hx ‚ä¢
    by_contra h
    -- h : x ‚àâ Set.Icc (-(R + Œ¥)) (R + Œ¥)
    -- But since simp already expanded it, h is ¬¨(-(R + Œ¥) ‚â§ x ‚àß x ‚â§ R + Œ¥)
    -- This means x < -(R + Œ¥) ‚à® R + Œ¥ < x
    rw [not_and_or] at h
    simp only [not_le] at h
    -- If x is outside this interval, then for any y in support(f),
    -- x - y is outside support(œÜŒ¥), so œÜŒ¥(x - y) = 0
    have h_integral_zero : ‚à´ y, s_R y * œÜŒ¥ (x - y) ‚àÇvolume = 0 := by
      rw [integral_eq_zero_of_ae]
      filter_upwards with y
      by_cases hy : s_R y = 0
      ¬∑ simp [hy]
      ¬∑ -- y ‚àà support(s_R), so |y| ‚â§ R
        have hy_support : y ‚àà Function.support s_R := by
          exact Function.mem_support.mpr hy
        have hy_bound : |y| ‚â§ R := by
          have := hs_R_support hy_support
          -- Since y ‚àà Set.Ioc 0 R, we have 0 < y ‚â§ R, so |y| = y ‚â§ R
          have hy_pos : 0 < y := this.1
          have hy_le : y ‚â§ R := this.2
          rw [abs_of_pos hy_pos]
          exact hy_le
        -- If |x| > R + Œ¥, then |x - y| > Œ¥, so œÜŒ¥(x - y) = 0
        have h_diff_large : Œ¥ < |x - y| := by
          cases h with
          | inl h =>
            -- Case: x + R < -Œ¥, which means x < -(R + Œ¥)
            have hx_neg : x < -(R + Œ¥) := by linarith [h]
            -- Since |y| ‚â§ R, we have y ‚â• -R, so x - y ‚â§ x - (-R) = x + R < -(R + Œ¥) + R = -Œ¥
            have h_bound : x - y < -Œ¥ := by
              calc x - y
                ‚â§ x + R := by
                    have : -R ‚â§ y := (abs_le.mp hy_bound).1
                    linarith [this]
                _ < -(R + Œ¥) + R := by linarith [hx_neg]
                _ = -Œ¥ := by ring
            -- Since x - y < -Œ¥ < 0, we have |x - y| = -(x - y) > Œ¥
            have h_abs : |x - y| = -(x - y) := abs_of_neg (by linarith [h_bound, hŒ¥_pos])
            rw [h_abs]
            linarith [h_bound]
          | inr h =>
            -- Case: R + Œ¥ < x
            have hx_pos : R + Œ¥ < x := h
            -- Since |y| ‚â§ R, we have y ‚â§ R, so x - y ‚â• x - R > (R + Œ¥) - R = Œ¥
            have h_bound : Œ¥ < x - y := by
              calc Œ¥
                = (R + Œ¥) - R := by ring
                _ < x - R := by linarith [hx_pos]
                _ ‚â§ x - y := by
                    have : y ‚â§ R := (abs_le.mp hy_bound).2
                    linarith [this]
            -- Since x - y > Œ¥ > 0, we have |x - y| = x - y > Œ¥
            have h_pos : 0 < x - y := by linarith [h_bound, hŒ¥_pos]
            rw [abs_of_pos h_pos]
            exact h_bound
        -- Since Œ¥ < |x - y|, we have |x - y| > Œ¥, so x - y ‚àâ [-Œ¥, Œ¥]
        -- This means x - y ‚àâ support œÜŒ¥, so œÜŒ¥(x - y) = 0
        have hœÜŒ¥_zero : œÜŒ¥ (x - y) = 0 := by
          apply Function.notMem_support.mp
          intro h_in_support
          -- hœÜŒ¥_support says support œÜŒ¥ ‚äÜ [-Œ¥, Œ¥], so if x - y ‚àà support œÜŒ¥, then |x - y| ‚â§ Œ¥
          have h_mem_interval := hœÜŒ¥_support h_in_support
          simp only [Set.mem_Icc] at h_mem_interval
          have : |x - y| ‚â§ Œ¥ := abs_le.mpr h_mem_interval
          -- But we proved Œ¥ < |x - y|, contradiction
          linarith [h_diff_large, this]
        simp [hœÜŒ¥_zero]
    exact hx h_integral_zero

  have hg_compactSupport : HasCompactSupport g := by
    -- Use the definition: HasCompactSupport g ‚Üî IsCompact (tsupport g)
    rw [HasCompactSupport]
    -- tsupport g = closure (support g), and support g ‚äÜ Set.Icc (-(R + Œ¥)) (R + Œ¥)
    simp only [tsupport]
    -- closure (support g) ‚äÜ closure (Set.Icc (-(R + Œ¥)) (R + Œ¥)) = Set.Icc (-(R + Œ¥)) (R + Œ¥)
    apply IsCompact.of_isClosed_subset isCompact_Icc isClosed_closure
    exact closure_minimal hg_support isClosed_Icc

  -- Show g ‚àà L¬≤ with the weighted measure
  have hs_R_vol_integrable : LocallyIntegrable s_R volume :=
    s_R_locally_integrable_volume hœÉ_lower hœÉ_upper s R hR_pos hs_R_memLp
  have hs_R_support' : Function.support s_R ‚äÜ Set.Icc (-R) R := by
    calc Function.support s_R
      ‚äÜ Set.Ioc 0 R := hs_R_support
      _ ‚äÜ Set.Icc 0 R := Set.Ioc_subset_Icc_self
      _ ‚äÜ Set.Icc (-R) R := by
        intro x hx
        simp at hx ‚ä¢
        exact ‚ü®le_trans (neg_nonpos_of_nonneg (le_of_lt hR_pos)) hx.1, hx.2‚ü©
  have hg_memLp : MemLp g 2 (weightedMeasure œÉ) :=
    convolution_memLp_weighted hœÉ_lower R Œ¥ hR_pos hŒ¥_pos hs_R_support' hs_R_memLp
    hs_R_vol_integrable hœÜŒ¥_smooth hœÜŒ¥_compact hœÜŒ¥_support

  use g, hg_memLp
  refine ‚ü®hg_compactSupport, hg_continuous, ?_‚ü©

  -- Show the distance bound using triangle inequality:
  -- dist s g ‚â§ dist s s_R + dist s_R g < Œµ/2 + Œµ/2 = Œµ
  calc dist s (hg_memLp.toLp g)
    _ ‚â§ dist s (hs_R_memLp.toLp s_R) + dist (hs_R_memLp.toLp s_R) (hg_memLp.toLp g) :=
      dist_triangle s (hs_R_memLp.toLp s_R) (hg_memLp.toLp g)
    _ < Œµ / 2 + Œµ / 2 := by
      apply add_lt_add
      ¬∑ -- First term: dist s s_R < Œµ/2 (from truncation error)
        -- Use the fact that truncation error is controlled
        -- Use h_truncation_error directly since the distance bounds are equivalent
        exact truncation_error_dist_bound s s_R hs_R_memLp (Œµ / 2) (by linarith : 0 < Œµ / 2)
          h_truncation_error
      ¬∑ -- Second term: dist s_R g < Œµ/2 (mollification error)
        -- Apply the standard mollification error bound
        -- We need to build the proper mollifier from our normalized œÜŒ¥
        -- First, we need to construct the base mollifier with support in [-1, 1]
        let œÜ_base := œÜ_normalized  -- Already normalized with integral = 1
        have hœÜ_base_smooth : ContDiff ‚Ñù (‚ä§ : ‚Ñï‚àû) œÜ_base := by
          sorry -- œÜ_normalized inherits smoothness from œÜ‚ÇÄ
        have hœÜ_base_compact : HasCompactSupport œÜ_base := by
          sorry -- œÜ_normalized has same support as œÜ‚ÇÄ
        have hœÜ_base_nonneg : ‚àÄ x, 0 ‚â§ œÜ_base x := by
          intro x
          simp [œÜ_base, œÜ_normalized]
          apply div_nonneg
          ¬∑ have := hœÜ‚ÇÄ_range (Set.mem_range_self x)
            exact this.1
          ¬∑ exact le_of_lt hœÜ‚ÇÄ_pos_integral
        have hœÜ_base_integral : ‚à´ x, œÜ_base x ‚àÇvolume = 1 := hœÜ_normalized_integral

        -- Now apply the standard mollification error
        have h_error := standard_mollification_l2_error hœÉ_lower s_R hs_R_memLp
          œÜ_base hœÜ_base_smooth hœÜ_base_compact hœÜ_base_nonneg hœÜ_base_integral
          Œ¥ (Œµ/2) hŒ¥_pos (by linarith : 0 < Œµ/2)

        -- The mollified function matches our g
        have hg_eq : g = fun x => ‚à´ y, s_R y * ((1/Œ¥) * œÜ_base ((x - y)/Œ¥)) ‚àÇvolume := by
          sorry -- Definitional equality after unfolding

        -- Apply the error bound
        have hŒ¥_small' : Œ¥ < (Œµ/2) / (4 * (ENNReal.toReal
          (eLpNorm s_R 2 (weightedMeasure œÉ)) + 1)) := by
          sorry -- This needs to be proven from our choice of Œ¥

        exact h_error hg_memLp hŒ¥_small'
    _ = Œµ := by ring

/-- Continuous compactly supported functions can be approximated
  by smooth compactly supported functions -/
lemma continuous_to_smooth_approx {œÉ : ‚Ñù} (hœÉ_lower : 1 / 2 < œÉ) (hœÉ_upper : œÉ < 3 / 2)
    (g_cont : ‚Ñù ‚Üí ‚ÑÇ) (hg_cont_memLp : MemLp g_cont 2 (weightedMeasure œÉ))
    (hg_cont_compact : HasCompactSupport g_cont) (hg_cont_continuous : Continuous g_cont)
    (Œµ : ‚Ñù) (hŒµ : 0 < Œµ) :
    ‚àÉ (g : ‚Ñù ‚Üí ‚ÑÇ) (hg_memLp : MemLp g 2 (weightedMeasure œÉ)),
      HasCompactSupport g ‚àß
      ContDiff ‚Ñù ‚ä§ g ‚àß
      dist (hg_cont_memLp.toLp g_cont) (hg_memLp.toLp g) < Œµ := by
  -- Use mollification to convert continuous compactly supported ‚Üí smooth compactly supported
  -- This is the standard mollification procedure using smooth bump functions
  -- Create a mollified version of g_cont using convolution with a smooth kernel
  -- The mollification preserves compact support and creates smoothness
  -- Apply mollification to get smooth compactly supported approximation with consistent measures
  sorry

/-- The weighted measure is equivalent to withDensity measure -/
lemma weightedMeasure_eq_withDensity (œÉ : ‚Ñù) :
    weightedMeasure œÉ = mulHaar.withDensity (fun x => ENNReal.ofReal (x ^ (2 * œÉ - 1))) := by
  -- This follows from the definition of weightedMeasure and weightFunction
  -- Note: this equality holds because the weight function is zero for x ‚â§ 0
  -- and the measure integration is restricted to positive reals
  sorry

/-- Smooth compactly supported functions are dense in weighted L¬≤ spaces for œÉ > 1/2 -/
lemma smooth_compactSupport_dense_in_weightedL2 {œÉ : ‚Ñù} (hœÉ_lower : 1 / 2 < œÉ)
    (hœÉ_upper : œÉ < 3 / 2)
    (f : HœÉ œÉ) (Œµ : ‚Ñù) (hŒµ : 0 < Œµ) : ‚àÉ (g : ‚Ñù ‚Üí ‚ÑÇ) (hg_mem : MemLp g 2
    (mulHaar.withDensity (fun x => ENNReal.ofReal (x ^ (2 * œÉ - 1))))),
     HasCompactSupport g ‚àß ContDiff ‚Ñù ‚ä§ g ‚àß dist f (hg_mem.toLp g) < Œµ := by
  -- Use the density of smooth compactly supported functions in weighted L¬≤ spaces
  -- Use the fact that for œÉ > 1/2, the weight function x^(2œÉ-1) is locally integrable
  have h_weight_integrable := weight_locallyIntegrable hœÉ_lower

  -- Step 1: First approximate by simple functions
  -- Elements of `HœÉ œÉ` are already in the weighted L¬≤ space used to define the norm
  have hf_mem_base := memLp_of_HœÉ (œÉ := œÉ) f

  have h_measure_equiv := weightedMeasure_eq_withDensity œÉ

  have hf_weightedMeasure :
      MemLp (HœÉ.toFun f) 2 (weightedMeasure œÉ) := by
    simpa [h_measure_equiv, HœÉ.toFun] using hf_mem_base

  -- Convert to Lp space element
  let f_Lp : Lp ‚ÑÇ 2 (weightedMeasure œÉ) :=
    hf_weightedMeasure.toLp (HœÉ.toFun f)

  -- Get simple function approximation from HilbertSpaceCore
  obtain ‚ü®s, hs_close‚ü© := exists_simple_func_approximation f_Lp (Œµ / 2) (half_pos hŒµ)

  have h_continuous_approx := lp_to_continuous_approx hœÉ_lower hœÉ_upper s (Œµ / 4) (by linarith)

  obtain ‚ü®g_cont, hg_cont_memLp, hg_cont_compact,
    hg_cont_continuous, hg_cont_close‚ü© := h_continuous_approx

  have h_smooth_approx := continuous_to_smooth_approx hœÉ_lower hœÉ_upper g_cont hg_cont_memLp
      hg_cont_compact hg_cont_continuous (Œµ / 4) (by linarith)

  obtain ‚ü®g, hg_memLp, hg_compact, hg_smooth, hg_mollify_close‚ü© := h_smooth_approx

  have h_measure_equiv_final := weightedMeasure_eq_withDensity œÉ

  -- Convert hg_memLp to the required measure type
  have hg_memLp_converted : MemLp g 2 (mulHaar.withDensity (fun x =>
    ENNReal.ofReal (x ^ (2 * œÉ - 1)))) := by
    rwa [h_measure_equiv_final] at hg_memLp

  use g, hg_memLp_converted
  constructor
  ¬∑ exact hg_compact
  constructor
  ¬∑ exact hg_smooth
  ¬∑ -- Convert distances to work with consistent measures
    -- Apply the approximation error bound
    have hs_close' : dist f_Lp s < Œµ / 2 := by
      rw [dist_comm]
      exact hs_close
    -- Apply distance bound through approximation chain using triangle inequality
    -- We have the chain: f ‚â° f_Lp ‚Üí s ‚Üí g_cont ‚Üí g where:
    -- dist(f_Lp, s) < Œµ/2, dist(s, g_cont) < Œµ/4, dist(g_cont, g) < Œµ/4

    -- Apply approximation bounds using the triangle inequality
    -- The goal is to show dist f (hg_memLp_converted.toLp g) < Œµ
    -- We have approximation steps: f ‚âà f_Lp ‚âà s ‚âà g_cont ‚âà g

    -- Step 1: Convert to common measure space and apply triangle inequality
    have h_approx_bound : dist f (hg_memLp_converted.toLp g) < Œµ := by
      -- The distance bound follows from:
      -- 1. f = f_Lp (by construction)
      -- 2. dist(f_Lp, s) < Œµ/2 (given)
      -- 3. dist(s, g_cont) < Œµ/4 (given)
      -- 4. dist(g_cont, g) < Œµ/4 (given)
      -- 5. Triangle inequality: dist(f, g) ‚â§ sum of intermediate distances

      -- Apply measure equivalence to work in the same space
      have h_measure_eq := h_measure_equiv_final

      -- The key insight: we can work directly with the distances in weightedMeasure space
      -- and use the fact that hg_memLp_converted corresponds to hg_memLp under measure equivalence

      -- Since f_Lp was constructed from f and hg_memLp_converted from hg_memLp,
      -- the distance should be equivalent to working in the original space
      have h_dist_equiv : dist f (hg_memLp_converted.toLp g) = dist f_Lp (hg_memLp.toLp g) :=
        lp_dist_measure_equiv f g f_Lp hf_weightedMeasure rfl hg_memLp hg_memLp_converted

      rw [h_dist_equiv]

      -- Apply triangle inequality in the weightedMeasure space: f_Lp ‚Üí s ‚Üí g_cont ‚Üí g
      -- The key insight is we have bounds:
      -- dist f_Lp s < Œµ/2, dist s g_cont < Œµ/4, dist g_cont g < Œµ/4
      have h_triangle_chain : dist f_Lp (hg_memLp.toLp g) < Œµ :=
        lp_approximation_triangle_chain f_Lp s g_cont hg_cont_memLp g hg_memLp Œµ hŒµ
          hs_close' hg_cont_close hg_mollify_close
      exact h_triangle_chain

    exact h_approx_bound

/-- Schwartz functions are dense in HœÉ for œÉ > 1/2 -/
theorem schwartz_dense_in_HœÉ {œÉ : ‚Ñù} (hœÉ_lower : 1 / 2 < œÉ) (hœÉ_upper : œÉ < 3 / 2) :
    DenseRange (schwartzToHœÉ hœÉ_lower) := by
  -- Use the characterization: a subspace is dense iff its closure equals the whole space
  rw [denseRange_iff_closure_range]
  -- Show that closure of range equals the whole space
  rw [Set.eq_univ_iff_forall]
  intro f
  -- For any f ‚àà HœÉ, we can approximate it arbitrarily well by Schwartz functions
  -- Use the characterization: f ‚àà closure S ‚Üî ‚àÄ Œµ > 0, ‚àÉ s ‚àà S, dist f s < Œµ
  rw [Metric.mem_closure_iff]
  intro Œµ hŒµ
  -- Need to find a Schwartz function œÜ such that dist f (schwartzToHœÉ hœÉ œÜ) < Œµ
  -- Strategy: First approximate f by a compactly supported smooth function,
  -- then extend it to a Schwartz function

  -- Step 1: Use the density of compactly supported smooth functions in L¬≤
  -- For this, we use the fact that C_c^‚àû functions are dense in L¬≤ spaces
  have h_smooth_dense := smooth_compactSupport_dense_in_weightedL2 hœÉ_lower hœÉ_upper f
    (Œµ / 2) (half_pos hŒµ)

  obtain ‚ü®g, hg_mem, hg_compact, hg_smooth, hg_close‚ü© := h_smooth_dense

  -- Step 2: Extend g to a Schwartz function
  -- Since g has compact support and is smooth, it's already a Schwartz function
  -- We just need to construct the SchwartzMap structure

  -- First verify that smooth compactly supported functions are Schwartz
  have hg_schwartz : ‚àÄ k n : ‚Ñï, ‚àÉ C : ‚Ñù, ‚àÄ x : ‚Ñù,
      ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n g x‚Äñ ‚â§ C := by
    intro k n
    -- Since g has compact support, say in [-R, R], and is smooth
    -- The bound is simply 0 outside [-R, R] and finite inside
    classical
    -- Define the auxiliary function whose boundedness we need
    set h : ‚Ñù ‚Üí ‚Ñù := fun x => ‚Äñx‚Äñ ^ k * ‚ÄñiteratedFDeriv ‚Ñù n g x‚Äñ
    have h_nonneg : ‚àÄ x, 0 ‚â§ h x := by
      intro x
      exact mul_nonneg (pow_nonneg (norm_nonneg _) _) (norm_nonneg _)
    -- Since g has compact support and is smooth, its derivatives also have compact support
    -- and are supported in the same set
    set K := tsupport g with hK_def
    have hK_compact : IsCompact K := by
      rw [hK_def]
      exact hg_compact
    have hK_subset : tsupport (iteratedFDeriv ‚Ñù n g) ‚äÜ K := by
      simpa [hK_def] using
        (tsupport_iteratedFDeriv_subset (ùïú := ‚Ñù) (f := g) (n := n))
    -- If the support is empty, the function vanishes everywhere and we can take C = 0
    by_cases h_empty : tsupport (iteratedFDeriv ‚Ñù n g) = ‚àÖ
    ¬∑ refine ‚ü®0, fun x => ?_‚ü©
      have hx_not : x ‚àâ tsupport (iteratedFDeriv ‚Ñù n g) := by simp [h_empty]
      have hx_zero : iteratedFDeriv ‚Ñù n g x = 0 :=
        image_eq_zero_of_notMem_tsupport hx_not
      simp [hx_zero]
    -- Otherwise, the image of h over the compact set K attains a maximum
    ¬∑ have h_tsupport_nonempty :
        (tsupport (iteratedFDeriv ‚Ñù n g)).Nonempty :=
        Set.nonempty_iff_ne_empty.mpr h_empty
      obtain ‚ü®x‚ÇÄ, hx‚ÇÄ_support‚ü© := h_tsupport_nonempty
      have hx‚ÇÄK : x‚ÇÄ ‚àà K := hK_subset hx‚ÇÄ_support
      -- Continuity of the auxiliary function
      have h_cont : Continuous h := by
        have h_pow_cont : Continuous fun x : ‚Ñù => ‚Äñx‚Äñ ^ k :=
          (continuous_norm : Continuous fun x : ‚Ñù => ‚Äñx‚Äñ).pow _
        have h_iter_cont :
            Continuous fun x : ‚Ñù => iteratedFDeriv ‚Ñù n g x :=
          (hg_smooth.continuous_iteratedFDeriv (m := n) (hm := by simp))
        exact h_pow_cont.mul (h_iter_cont.norm)
      -- The image of h on K is compact, hence admits a greatest element
      have h_image_compact : IsCompact (h '' K) := hK_compact.image h_cont
      have h_image_nonempty : (h '' K).Nonempty := ‚ü®h x‚ÇÄ, ‚ü®x‚ÇÄ, hx‚ÇÄK, rfl‚ü©‚ü©
      obtain ‚ü®C, hC_isGreatest‚ü© :=
        h_image_compact.exists_isGreatest h_image_nonempty
      rcases hC_isGreatest with ‚ü®hC_mem, hC_max‚ü©
      rcases hC_mem with ‚ü®xC, hxC_K, rfl‚ü©
      have hC_le : ‚àÄ y ‚àà h '' K, y ‚â§ h xC := (mem_upperBounds).1 hC_max
      refine ‚ü®h xC, ?_‚ü©
      intro x
      by_cases hxK : x ‚àà K
      ¬∑ have hx_mem : h x ‚àà h '' K := ‚ü®x, hxK, rfl‚ü©
        exact hC_le _ hx_mem
      ¬∑ have hx_not : x ‚àâ tsupport (iteratedFDeriv ‚Ñù n g) := fun hx => hxK (hK_subset hx)
        have hx_zero : iteratedFDeriv ‚Ñù n g x = 0 := image_eq_zero_of_notMem_tsupport hx_not
        have hC_nonneg : 0 ‚â§ h xC := h_nonneg xC
        have hx_val : h x = 0 := by simp [h, hx_zero]
        have hx_le : h x ‚â§ h xC := by simpa [hx_val] using hC_nonneg
        simpa [h] using hx_le

  -- Construct the Schwartz function from g
  -- Note: SchwartzMap requires ContDiff ‚Ñù (‚Üë‚ä§) but we have ContDiff ‚Ñù ‚ä§
  -- These are the same, but we need to handle the type difference
  have hg_smooth' : ContDiff ‚Ñù ((‚ä§ : ‚Ñï‚àû) : WithTop ‚Ñï‚àû) g :=
    hg_smooth.of_le (by simp)
  let œÜ : SchwartzMap ‚Ñù ‚ÑÇ := ‚ü®g, hg_smooth', hg_schwartz‚ü©

  -- Step 3: Show that schwartzToHœÉ hœÉ_lower œÜ approximates f
  -- We need to show ‚àÉ y ‚àà Set.range (schwartzToHœÉ hœÉ_lower), dist f y < Œµ
  use schwartzToHœÉ hœÉ_lower œÜ
  refine ‚ü®?_, ?_‚ü©
  ¬∑ -- Show that schwartzToHœÉ hœÉ œÜ is in the range
    use œÜ
  ¬∑ -- Show the distance bound
    classical
    set Œº := mulHaar.withDensity (fun x => ENNReal.ofReal (x ^ (2 * œÉ - 1))) with hŒº
    have hŒº_zero : Œº (Set.Iic (0 : ‚Ñù)) = 0 := by
      -- First note that the underlying Haar measure vanishes on nonpositive reals
      have h_base_zero : mulHaar (Set.Iic (0 : ‚Ñù)) = 0 := by
        have h_inter : Set.Iic (0 : ‚Ñù) ‚à© Set.Ioi (0 : ‚Ñù) = (‚àÖ : Set ‚Ñù) := by
          ext x
          constructor
          ¬∑ intro hx
            rcases hx with ‚ü®hx_le, hx_gt‚ü©
            have hx_not : ¬¨(0 < x) := not_lt_of_ge hx_le
            exact (hx_not hx_gt).elim
          ¬∑ intro hx
            simp at hx
        have h_meas : MeasurableSet (Set.Iic (0 : ‚Ñù)) := measurableSet_Iic
        have :
            mulHaar (Set.Iic (0 : ‚Ñù)) =
              (volume.withDensity fun x : ‚Ñù => ENNReal.ofReal (1 / x))
                (Set.Iic (0 : ‚Ñù) ‚à© Set.Ioi (0 : ‚Ñù)) := by
          simp [mulHaar, h_meas]
        simpa [h_inter] using this
      -- Absolute continuity of the weighted measure
      have h_ac :=
        withDensity_absolutelyContinuous
          (Œº := mulHaar) (f := fun x => ENNReal.ofReal (x ^ (2 * œÉ - 1)))
      have : Œº ‚â™ mulHaar := by
        simpa [hŒº] using h_ac
      exact this.null_mono h_base_zero
    -- The two L¬≤ representatives coincide almost everywhere
    have h_ae_eq : g =·µê[Œº] fun x : ‚Ñù => if x > 0 then g x else 0 := by
      have h_subset :
          {x : ‚Ñù | g x ‚â† if x > 0 then g x else 0} ‚äÜ Set.Iic (0 : ‚Ñù) := by
        intro x hx
        by_contra hx_pos
        have hx_pos' : 0 < x := lt_of_not_ge hx_pos
        change g x ‚â† if x > 0 then g x else 0 at hx
        rw [if_pos hx_pos'] at hx
        exact hx rfl
      have h_diff_zero :
          Œº {x : ‚Ñù | g x ‚â† if x > 0 then g x else 0} = 0 :=
        measure_mono_null h_subset hŒº_zero
      refine (ae_iff).2 ?_
      simpa using h_diff_zero
    -- therefore the corresponding L¬≤ elements coincide
    have h_toLp_eq :
        hg_mem.toLp g =
          MemLp.toLp (fun x : ‚Ñù => if x > 0 then œÜ x else 0)
            (schwartz_mem_HœÉ hœÉ_lower œÜ) := by
      have h_ae_eq' : g =·µê[Œº] fun x : ‚Ñù => if x > 0 then œÜ x else 0 := by
        simpa [hŒº] using h_ae_eq
      exact
        ((MemLp.toLp_eq_toLp_iff (hf := hg_mem)
              (hg := schwartz_mem_HœÉ hœÉ_lower œÜ)).2 h_ae_eq')
    have h_toLp_eq' : hg_mem.toLp g = schwartzToHœÉ hœÉ_lower œÜ := by
      simpa [schwartzToHœÉ, hŒº] using h_toLp_eq
    -- Conclude using the approximation provided by `hg_close`
    have h_lt : dist f (hg_mem.toLp g) < Œµ :=
      lt_trans hg_close (half_lt_self hŒµ)
    simpa [h_toLp_eq'] using h_lt

/-- For any f ‚àà HœÉ and Œµ > 0, there exists a Schwartz function approximating f for œÉ > 1/2 -/
lemma exists_schwartz_approximation {œÉ : ‚Ñù} (hœÉ_lower : 1 / 2 < œÉ) (hœÉ_upper : œÉ < 3 / 2)
    (f : HœÉ œÉ) (Œµ : ‚Ñù) (hŒµ : 0 < Œµ) :
    ‚àÉ œÜ : SchwartzMap ‚Ñù ‚ÑÇ, ‚ÄñschwartzToHœÉ hœÉ_lower œÜ - f‚Äñ < Œµ := by
  have h_dense := schwartz_dense_in_HœÉ hœÉ_lower hœÉ_upper
  -- h_dense: Dense (Set.range (schwartzToHœÉ hœÉ_lower))
  -- This means closure (Set.range (schwartzToHœÉ hœÉ_lower)) = Set.univ
  have hf_in_closure : f ‚àà closure (Set.range (schwartzToHœÉ hœÉ_lower)) := by
    have : closure (Set.range (schwartzToHœÉ hœÉ_lower)) = Set.univ := Dense.closure_eq h_dense
    rw [this]
    exact Set.mem_univ f
  rw [Metric.mem_closure_iff] at hf_in_closure
  obtain ‚ü®g, hg_range, hg_close‚ü© := hf_in_closure Œµ hŒµ
  obtain ‚ü®œÜ, rfl‚ü© := hg_range
  use œÜ
  rw [dist_eq_norm] at hg_close
  rw [‚Üênorm_sub_rev]
  exact hg_close

/-- Schwartz approximation with a.e. convergence for œÉ > 1/2 -/
lemma schwartz_ae_dense {œÉ : ‚Ñù} (hœÉ_lower : 1 / 2 < œÉ) (hœÉ_upper : œÉ < 3 / 2)
    (f : HœÉ œÉ) (Œµ : ‚Ñù) (hŒµ : 0 < Œµ) :
    ‚àÉ œÜ : SchwartzMap ‚Ñù ‚ÑÇ, ‚ÄñschwartzToHœÉ hœÉ_lower œÜ - f‚Äñ < Œµ ‚àß
    (schwartzToHœÉ hœÉ_lower œÜ : ‚Ñù ‚Üí ‚ÑÇ) =·µê[mulHaar.withDensity (fun x =>
      ENNReal.ofReal (x ^ (2 * œÉ - 1)))] (fun x => if x > 0 then œÜ x else 0) := by
  obtain ‚ü®œÜ, hœÜ‚ü© := exists_schwartz_approximation hœÉ_lower hœÉ_upper f Œµ hŒµ
  use œÜ
  constructor
  ¬∑ exact hœÜ
  ¬∑ exact schwartzToHœÉ_ae_eq hœÉ_lower œÜ

end SchwartzDensity

end Frourio
